#autoload

# This is intended to be used as a completer function after the normal
# completer as in: `zstyle ":completion:::::" completer _complete _match'.
# It temporarily switches on pattern matching, allowing you to try 
# completion on patterns without having to setopt glob_complete.
#
# Note, however, that this is only really useful if you don't use the
# expand-or-complete function because otherwise the pattern will
# be expanded using globbing.

[[ _matcher_num -gt 1 ]] && return 1

local tmp opm="$compstate[pattern_match]" ret=0 orig ins

# Do nothing if we don't have a pattern.

tmp="${${:-$PREFIX$SUFFIX}#[~=]}"
[[ "$tmp:q" = "$tmp" ]] && return 1

zstyle -s ":completion:${curcontext}:" match-original orig
zstyle -b ":completion:${curcontext}:" insert-unambiguous ins

# Try completion without inserting a `*'?

if [[ -n "$orig" ]]; then
  compstate[pattern_match]='-'
  _complete && ret=1
  compstate[pattern_match]="$opm"

  if (( ret )); then
    [[ "$ins" = yes &&
       $#compstate[unambiguous] -ge ${#:-${PREFIX}${SUFFIX}} ]] && 
        compstate[pattern_insert]=unambiguous
    return 0
  fi
fi

# No completion with inserting `*'?

[[ "$orig" = only ]] && return 1

compstate[pattern_match]='*'
_complete && ret=1
compstate[pattern_match]="$opm"

[[ ret -eq 1 && "$ins" = yes &&
   $#compstate[unambiguous] -ge ${#:-${PREFIX}${SUFFIX}} ]] && 
    compstate[pattern_insert]=unambiguous

return 1-ret
