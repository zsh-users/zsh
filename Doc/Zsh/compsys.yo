texinode(Completion System)(Completion Using compctl)(Completion Widgets)(Top)
chapter(Completion System)
cindex(completion system)
cindex(completion, programmable)
cindex(completion, controlling)
sect(Description)

This describes the shell code for the new completion system.  It consists
of various shell functions; those beginning `tt(comp)' are to be called
directly by the user, while those beginning `tt(_)' are called by the
completion code.  The shell functions of the second set which implement
completion behaviour and which may be bound to keystrokes, are referred to
as `widgets'.

startmenu()
menu(Initialization)
menu(Completion System Configuration)
menu(Control Functions)
menu(Bindable Commands)
menu(Completion Functions)
menu(Completion Directories)
endmenu()

texinode(Initialization)(Completion System Configuration)()(Completion System)
sect(Initialization)
findex(compinstall)
cindex(completion system, installing)

If the system was installed completely, it should be enough to
call the shell function tt(compinit) from your initialization file; see the
next section.  However, the function tt(compinstall) can be run by a user
to configure various aspects of the completion system.

Usually, tt(compinstall) will insert code into tt(.zshrc), although if
that is not writable it will save it in another file and tell you that
file's location.  Note that it is up to you to make sure that the lines
added to tt(.zshrc) are actually run; you may, for example, need to move
them to an earlier place in the file if tt(.zshrc) usually returns early.
So long as you keep them all together (including the comment lines at the
start and finish), you can rerun tt(compinstall) and it will correctly
locate and modify these lines.  Note, however, that any code you add to
this section by hand is likely to be lost if you rerun tt(compinstall),
although lines using the command `tt(zstyle)' should be gracefully handled.

The new code will take effect next time you start the shell, or run
tt(.zshrc) by hand; there is also an option to make them take effect
immediately.  However, if tt(compinstall) has removed definitions, you will
need to restart the shell to see the changes.

To run tt(compinstall) you will need to make sure it is in a directory
mentioned in your tt(fpath) parameter, which should already be the case if
zsh was properly configured as long as your startup files do not remove the
appropriate directories from tt(fpath).  Then it must be autoloaded
(`tt(autoload -U compinstall)' is recommended).  You can abort the
installation any time you are being prompted for information, and your
tt(.zshrc) will not be altered at all; changes only take place right at the
end, where you are specifically asked for confirmation.

subsect(Use of compinit)
findex(compinit)
cindex(completion system, initializing)

This section describes the use of tt(compinit) to initialize completion for
the current session when run directly by the user; if you have run
tt(compinstall) it will be called automatically from your tt(.zshrc).

To initialize the system, the function tt(compinit) should be in a
directory mentioned in the tt(fpath) parameter, and should be autoloaded
(`tt(autoload -U compinit)' is recommended), and then run simply as
`tt(compinit)'.  This will define a
few utility functions, arrange for all the necessary shell functions to be
autoloaded, and will then re-define all widgets that do completion to use the
new system.  If you use the tt(menu-select) widget, which is part of the
tt(zsh/complist) module, you should make sure that that module is loaded
before the call to tt(compinit) so that that widget is also
re-defined.  If completion styles (see below) are set up to perform
expansion as well as completion by default, and the TAB key is bound to
tt(expand-or-complete), tt(compinit) will rebind it to tt(complete-word);
this is necessary to use the correct form of expansion.

Should you need to use the original completion commands, you can still
bind keys to the old widgets by putting a `tt(.)' in front of the
widget name, e.g. `tt(.expand-or-complete)'.

To speed up the running of tt(compinit), it can be made to produce a dumped
configuration which will be read in on future invocations; this is the
default, although it can be turned off by calling tt(compinit) with the
option tt(-D).  The dumped file is tt(.zcompdump) in the same
directory as the startup files (i.e. tt($ZDOTDIR) or tt($HOME));
alternatively, an explicit file name can be given by `tt(compinit -d)
var(dumpfile)'.  On the next call to tt(compinit), it will read the dumped
file instead of performing a full initialization.

If the number of completion files changes, tt(compinit) will recognise this
and produce a new dump file.  However, if the name of a function or the
arguments in the first line of a tt(#compdef) function (as described below)
change, it is easiest to delete the dump file by hand so that
tt(compinit) will re-create it the next time it is run.  The check
performed to see if there are new functions can be omitted by giving
the option tt(-C).  In this case the dump file will only be created if
there isn't one already.

The dumping is actually done by another function, tt(compdump), but you
will only need to run this yourself if you change the configuration
(e.g. using tt(compdef)) and then want to dump the new one.  The name of
the old dumped file will be remembered for this purpose.

If the parameter tt(_compdir) is set, tt(compinit) uses it as a directory
where completion functions can be found; this is only necessary if they are
not already in the function search path.

For security reasons tt(compinit) also checks if the completion system
would use files not owned by root or by the current user, or files in
directories that are world- or group-writable or that are not owned by 
root or by the current user.  If such files or directories are found,
tt(compinit) will ask if the completion system should really be used.  To
avoid these tests and make all files found be used without asking, use the
option tt(-u), and to make tt(compinit) silently ignore all insecure files
and directories use the option tt(-i).  This security check is skipped
entirely when the tt(-C) option is given.

findex(compaudit)
The security check can be retried at any time by running the function
tt(compaudit).  This is the same check used by tt(compinit), but when it
is executed directly any changes to tt(fpath) are made local to the
function so they do not persist.  The directories to be checked may be
passed as arguments; if none are given, tt(compaudit) uses tt(fpath) and
tt(_compdir) to find completion system directories, adding missing ones
to tt(fpath) as necessary.  To force a check of exactly the directories
currently named in tt(fpath), set tt(_compdir) to an empty string before
calling tt(compaudit) or tt(compinit).

subsect(Autoloaded files)
cindex(completion system, autoloaded functions)

The convention for autoloaded functions used in completion is that they
start with an underscore; as already mentioned, the tt(fpath/FPATH)
parameter must contain the directory in which they are stored.  If tt(zsh)
was properly installed on your system, then tt(fpath/FPATH) automatically
contains the required directories for the standard functions.

For incomplete installations, if tt(compinit) does not find enough files
beginning with an underscore (fewer than twenty) in the search path, it
will try to find more by adding the directory tt(_compdir) to the search
path.  If that directory has a subdirectory named tt(Base), all
subdirectories will be added to the path.  Furthermore, if the subdirectory
tt(Base) has a subdirectory named tt(Core), tt(compinit) will add all
subdirectories of the subdirectories is to the path: this allows
the functions to be in the same format as in the tt(zsh) source
distribution.

cindex(compdef, use of by compinit)
When tt(compinit) is run, it searches all such files accessible via
tt(fpath/FPATH) and reads the first line of each of them.  This line should
contain one of the tags described below.  Files whose first line does not
start with one of these tags are not considered to be part of the
completion system and will not be treated specially.

The tags are:

startitem()
item(tt(#compdef) var(names...))(
The file will be made autoloadable and the function defined 
in it will be called when completing var(names), each of which is
either the name of a command whose arguments are to be completed or one of
a number of special contexts in the form tt(-)var(context)tt(-) described
below for the tt(_complete) function.

Each var(name) may also be of the form `var(cmd)tt(=)var(service)'.  This
is used by functions that offer multiple services, i.e. different
completion behaviour for multiple commands.  Such a string
makes the completion system call the function when completing
arguments for the command `tt(cmd)', setting the parameter tt($service) 
to the string `tt(service)'.  The function can then use that parameter 
to decide what to complete.
)
item(tt(#compdef -p) var(pattern))(
The file will be made autoloadable and the function defined in it will be
called when completing for a command whose name matches the given
var(pattern) (a standard globbing pattern).  Note that only one
var(pattern) may be given.
)
item(tt(#compdef -P) var(pattern))(
Like the previous one, but the function will be called only if no
completion function for the command on the line could be found.
)
item(tt(#compdef -k) var(style key-sequences...))(
This can be used to bind special completion functions to the
var(key-sequences) specified.  It creates a widget behaving like the
builtin widget var(style), which must be one of those that perform
completion, namely tt(complete-word), tt(delete-char-or-list),
tt(expand-or-complete), tt(expand-or-complete-prefix), tt(list-choices),
tt(menu-complete), tt(menu-expand-or-complete), or
tt(reverse-menu-complete).  If the tt(zsh/complist) module is loaded (see
ifzman(zmanref(zshmodules))\
ifnzman(noderef(The zsh/complist Module))\
), the same happens to the tt(menu-select) widget.

The widget is then bound to all the var(key-sequences) given, if any: when
one of the var(key-sequences) is typed, the function in the file will
be invoked to generate the matches.  Note that a key will not be re-bound
if if it already was (that is, was bound to something other than
tt(undefined-key)).  The widget created has the same name as the file and
can be bound to any other keys using tt(bindkey) as usual.
)
item(tt(#compdef -K) var(widget-name) var(style) var(key-sequences) ...)(
This is similar to tt(-k), with the same var(style) and var(key-sequences)
arguments, preceded by a string giving the name of a widget.
In this case only one var(key-sequences) argument may be given, but the
entire set of three arguments may be repeated with a different set of
arguments.  In particular, the var(widget-name) must be distinct in each
set.  It should begin with `tt(_)', else one will be added, and should not
clash with the name of any existing widget: names based on the name of the
function are most useful.  For example,

example(#compdef -K _foo_complete complete-word "^X^C" \ 
  _foo_list list-choices "^X^D")

(all on one line) defines a widget tt(_foo_complete) for completion, bound
to `tt(^X^C)', and a widget tt(_foo_list) for listing, bound to `tt(^X^D)'.
)
item(tt(#autoload) [ var(options) ])(
This is used for files defining utility functions that are not to be
called directly as completion functions but should be loaded automatically
when invoked.  Typically they are to be called from within one of the
completion functions.

The var(options) will be given to the tt(autoload) builtin command
when making the function autoloaded.  Most often, this will be tt(+X) to
force the function to be loaded immediately.  Note that the tt(-U) flag is
always implicitly added.
)
enditem()

The tt(#) is part of the tag name and no white space is allowed after it.
The tt(#compdef) tags use the tt(compdef) function described below; the
main difference is that the name of the function is supplied implicitly.

Note also that the functions for the completion system assume that the
tt(KSH_AUTOLOAD) option is not set and cannot be loaded when it is
set.  To avoid having to unset tt(KSH_AUTOLOAD), you can instead use one or
more tt(zwc) file(s) which have been created with the command tt(zcompile
-z) to load the functions for the completion system; see
ifzman(zmanref(zshbuiltins))\
ifnzman(noderef(Shell Builtin Commands))\
.  This forces the functions to be autoloaded the way zsh normally
loads functions.

subsect(Functions)

The tt(compinit) file defines the following function, which may
also be called directly by the user.

findex(compdef)
cindex(completion system, adding definitions)
startitem()
xitem(tt(compdef) [ tt(-an) ] var(function names...))
xitem(tt(compdef -d) var(names...))
xitem(tt(compdef -p) [ tt(-a) ] var(function pattern))
xitem(tt(compdef -P) [ tt(-a) ] var(function pattern))
xitem(tt(compdef -k) [ tt(-an) ] var(function style key-sequences...))
item(tt(compdef -K) [ tt(-an) ] var(function name style key-sequences ...))(
The first form tells the completion system to call the given
var(function) when completing for the contexts or commands
whose var(names) are given:  this is like the tt(#compdef) tag unless
the first word contains an equal sign.  In this case all words have to 
be of the form `var(cmd)tt(=)var(service)' where var(service) is the
name of a command or of a service defined by an autoloaded function
with the tt(#compdef) tag and an argument of the form
`var(cmd)tt(=)var(service)'.  This kind of use makes the arguments of
the var(cmd)s be completed as those for the var(services).

If the
tt(-n) option is given, any existing completion behaviour for particular
contexts or commands will not be altered.  These definitions can be deleted
by giving the tt(-d) option as in the second form.

The form with tt(-p) is similar to the first, but var(function) will be
called for all commands whose name matches the var(pattern); this is like
the tt(#compdef -p) function tag.

The form with tt(-P) is like the third, but the var(function) will be
called only if no function for the command itself was found or if one
was found and it set the tt(_compskip) parameter to a value em(not)
containing the substring tt(patterns).

The form with tt(-k) defines a widget with the same name as the var(function)
which will be called for each of the var(key-sequences); this is like the
tt(#compdef -k) tag.  The function should generate the completions needed
and will otherwise behave like the builtin widget whose name is given as
the var(style) argument. The widgets usable for this are:
tt(complete-word), tt(delete-char-or-list), tt(expand-or-complete),
tt(expand-or-complete-prefix), tt(list-choices), tt(menu-complete),
tt(menu-expand-or-complete), and tt(reverse-menu-complete), as well as
tt(menu-select) if the tt(zsh/complist) module is loaded.  The option tt(-n)
prevents the key being bound if it is already to bound to something other
than tt(undefined-key).

The form with tt(-K) is similar and defines multiple widgets based on the
same var(function), each of which requires the set of three arguments
var(name), var(style) and var(key-sequences), where the latter two are as
for tt(-k) and the first must be a unique widget name beginning with an
underscore.

In each of the forms supporting it the tt(-a) option makes the
var(function) autoloadable (exactly equivalent to
tt(autoload -U )var(function)).
)
enditem()

The tt(compdef) function is the place to turn to when one wants to
define what the completion system should complete for a certain
command.  The function named can of course be one of the functions
supplied or one written by the user.  For example, if one has a
command tt(foo) that gets process identifiers as arguments, one could
do:

example(compdef _pids foo)

using the tt(_pids) function from the distribution to generate the
process identifiers.  Not also the tt(_gnu_generic) function described
below, which can be used to complete options for commands that
understand the `tt(-)tt(-help)' option.

texinode(Completion System Configuration)(Control Functions)(Initialization)(Completion System)
sect(Completion System Configuration)
cindex(completion system, configuration)

This section gives a short overview of how the completion system works,
and then more detail on how users can configure how and when matches are
generated.

subsect(Overview)

When completion is attempted somewhere on a command line the
completion system first tries to find out the context where completion 
was tried.  The context depends on such things as the name of the
command when completing an argument, and possibly also
the name of an option when completing an argument to that option.

The `context' of a completion is a string consisting of multiple fields. This
is used to look up styles that can be used to configure the
completion system.  Since it is not possible to build the whole context 
string in advance, completion functions may modify some of the fields and 
hence the context used for lookup may vary during the same call
to the completion system.

The context string always consists of the following fields, separated
by colons and with a leading colon before the first:

startitemize()
itemiz(\
The literal string tt(completion), saying that this style is used by
the completion system.
)
itemiz(\
The var(function); in many cases this field will be blank, but when
the completion system is called from other functions, like
tt(predict-on) or one of the functions in the tt(Command) directory of 
the distribution, this field contains the name of that function, often
in an abbreviated form.
)
itemiz(\
The var(completer) currently active, which is the name of the function
without the leading underscore.  A `completer' is in
overall control of how completion is to be performed; `tt(complete)'
is the basic one for ordinary completion, but completers may perform
various related tasks such as correction, or modify the behaviour of a
later completer (see
ifzman(the section `Control Functions' below)\
ifnzman(noderef(Control Functions)) 
for more information).  
)
itemiz(\
The var(context) or var(command).  This is either one of the special
context names such as tt(-condition-) as explained for the
tt(_complete) completer below, or the name of the command we are
completing arguments for.  Completion functions for commands that have
sub-commands usually modify this field to contain the name of the
command followed by a minus sign and the sub-command (e.g. the
completion function for the tt(cvs) command sets this field to strings
such as tt(cvs-add) when completing for the tt(add) sub-command).
)
itemiz(\
The var(argument), describing which argument we are
completing.  Normally this is either a string of the form
tt(argument-)var(n), where var(n) is the number of the argument or it
is a string of the form tt(option-)var(opt)tt(-)var(n) when completing the
var(n)'th argument of the option var(opt).
)
itemiz(\
The var(tag).  Tags are used to discriminate between the types
of matches a completion function can generate in a certain context.
)
enditemize()

As an example, the context name

example(tt(:completion::complete:dvips:option-o-1:files))

says that normal completion was attempted on an argument of the tt(dvips)
command (more precisely: completion was attempted on the first argument
after the tt(-o) option) and the completion function will generate
filenames for this context.

In many of the possible contexts the completion system can generate
matches, often multiple types of matches.  These types are represented as
simple names called `tags'.  The completion system will decide internally
what sort of tags are allowed; a list of the standard possibilities is given
below.  To determine in which order the tags are to be used by the
completion function, the `tt(tag-order)' style for the appropriate
context may be set, as described in the list of standard styles below.
Only those types of matches whose tags were selected by this style
will be produced, and in the order given, although the default is to try
all relevant tags in an order determined by the particular completion in
use.

The tt(_complete_help) bindable command described in 
ifzman(the section `Bindable Commands' below)\
ifnzman(noderef(Bindable Commands))
can be invoked to find out the context and tag names and styles used at a
particular point in completion.  It shows the list of contexts and tags 
that would be used in if completion were tried at the current cursor
position.  Hence one can easily find out all the information needed to
change the behaviour of the tt(tag-order) style for a particular context.

Completion behaviour can be modified by various other
styles defined with the tt(zstyle) builtin command (\
ifzman(see zmanref(zshmodules))\
ifnzman(noderef(The zsh/zutil Module))).
When looking up styles the completion system uses full context names,
including the tag.

Styles determine such things as how the matches are generated; some of them
correspond to shell options (for example, the use of menu completion), but
styles provide more specific control.  They can have any number of strings as
their value.  Looking up the value of a style therefore consists of two
things:  the context, which may be matched as a pattern, and the name of
the style itself, which must be given exactly.

For example, many completion functions can generate matches in a
simple and a verbose form and use the tt(verbose) style to decide
which form should be used.  To make all such functions use the verbose form,
put

example(zstyle ':completion:*' verbose yes)

in one of the startup files like tt(.zshrc); this sort of style can also be
configured with the tt(compinstall) function.  This definition simply
means that the tt(verbose) style has tt(yes) as its value in every
context inside the completion system.  If the context pattern were `tt(*)',
the verbose style would have this value anywhere the style mechanism is
used, not just in completion.

As a more specific example, the completion function for the tt(kill)
builtin command uses the tt(verbose) style to decide if jobs and processes
are listed only as job numbers and process identifiers or if they are
listed with the full job texts and the command lines of the processes (the
latter is achieved by calling the tt(ps) command).  To make this builtin
list the matches only as numbers one could call:

example(zstyle ':completion:*:*:kill:*' verbose no)

Furthermore, if one wanted to see the command lines for processes but not the
job texts one could use the fact that the context name contains the tag name
when styles are looked up.  As the function for the tt(kill)
builtin command uses the tags tt(jobs) and tt(processes), we can use:

example(zstyle ':completion:*:*:kill:*:jobs' verbose no)

To have more control over when certain values for styles are used one
can use the special parameters available in completion widgets (see
ifzman(see zmanref(zshcompwid))\
ifnzman(noderef(Completion Widgets)))\
) and the tt(-e) option to tt(zstyle) that makes the value be
evaluated when looked up.  For example, to make the tt(completer)
style have a different value when completing for the tt(cvs) command,
one could use the tt(words) special array:

example(zstyle -e ':completion:*' completer '
    if [[ $words[1] = cvs ]]; then
      reply=(_complete)
    else
      reply=(_complete _approximate)
    fi')

One should be careful not to use too complicated code with this
option, at least for the styles that are looked up quite often.  These 
are basically those that define some global completion behaviour but
allow that to be different for all matches or groups of matches (such
as the tt(menu) and tt(list-rows-first) styles).  Alternatively one
can always use a less general pattern for the context than in the
example above and use a second call to tt(zstyle) with a generic
pattern and without using the tt(-e) option to define the default
behaviour.

Note that the order in which styles are em(defined) does not matter; the
style mechanism uses the most specific possible match for a particular
style to determine the set of values.  More precisely, strings are
preferred over patterns (for example, `tt(:completion::complete:foo)' is
more specific than `tt(:completion::complete:*')), and longer patterns are
preferred over shorter patterns.

As with tags, completion functions can use any style they choose, so
there can't be a complete list.  However, the following two sections
list those tags and styles that are used in many places of the
completion system.

subsect(Standard Tags)
cindex(completion system, tags)

Here are the tags currently used by the completion system.  Some of them
are only used when looking up styles and do not refer to a particular type
of match.

startitem()
kindex(accounts, completion tag)
item(tt(accounts))(
used to look up the tt(users-hosts) style
)
kindex(all-expansions, completion tag)
item(tt(all-expansions))(
used by the tt(_expand) completer when adding the single string containing
all possible expansions
)
kindex(all-files, completion tag)
item(tt(all-files))(
for the names of all files (as distinct from a particular subset, see the
tt(globbed-files) tag).
)
kindex(arguments, completion tag)
item(tt(arguments))(
when an argument of a command may be completed
)
kindex(arrays, completion tag)
item(tt(arrays))(
for names of array parameters
)
kindex(association-keys, completion tag)
item(tt(association-keys))(
for keys of associative arrays; used when completing inside a
subscript of a parameter of this type
)
kindex(bookmarks, completion tag)
item(tt(bookmarks))(
when completing bookmarks (e.g. for URLs and the tt(zftp) function suite)
)
kindex(builtins, completion tag)
item(tt(builtins))(
for names of builtin commands
)
kindex(characters, completion tag)
item(tt(characters))(
used for commands like tt(stty) when completing characters; also used
when completing character classes after a opening bracket
)
kindex(colormapids, completion tag)
item(tt(colormapids))(
for X colormap ids
)
kindex(colors, completion tag)
item(tt(colors))(
for color names
)
kindex(commands, completion tag)
item(tt(commands))(
for names of external commands and names of sub-commands (used by some 
commands like tt(cvs))
)
kindex(contexts, completion tag)
item(tt(contexts))(
for contexts used by the zstyle builtin command
)
kindex(corrections, completion tag)
item(tt(corrections))(
used by the tt(_approximate) and tt(_correct) completers for the possible
corrections
)
kindex(cursors, completion tag)
item(tt(cursors))(
for cursor names used by X programs
)
kindex(default, completion tag)
item(tt(default))(
used to look up default values for various styles that may also be set 
for tags that are used when generating matches; note that this tag is
used when only the var(function) field of the context name is set up
)
kindex(descriptions, completion tag)
item(tt(descriptions))(
used when looking up the value of the tt(format) style for
descriptions
)
kindex(devices, completion tag)
item(tt(devices))(
for names of device special files
)
kindex(directories, completion tag)
item(tt(directories))(
for names of directories
)
kindex(directory-stack, completion tag)
item(tt(directory-stack))(
for entries in the directory stack
)
kindex(displays, completion tag)
item(tt(displays))(
for X display names
)
kindex(domains, completion tag)
item(tt(domains))(
for network domains
)
kindex(expansions, completion tag)
item(tt(expansions))(
used by the tt(_expand) completer for individual possibilities resulting
from expansion of a word
)
kindex(extensions, completion tag)
item(tt(extensions))(
for X server extensions
)
kindex(file-descriptors, completion tag)
item(tt(file-descriptors))(
for the numbers of open file descriptors
)
kindex(files, completion tag)
item(tt(files))(
the generic file-matching tag used by completion functions that can
complete the names of some kind of file
)
kindex(fonts, completion tag)
item(tt(fonts))(
used for X font names
)
kindex(functions, completion tag)
item(tt(functions))(
names of functions, normally shell functions although certain commands may
understand other kinds of function
)
kindex(globbed-files, completion tag)
item(tt(globbed-files))(
for names of files matching the glob pattern used by completion
functions that expect a certain type of file
)
kindex(groups, completion tag)
item(tt(groups))(
used when completing names of user groups
)
kindex(history-words, completion tag)
item(tt(history-words))(
for words from the history
)
kindex(hosts, completion tag)
item(tt(hosts))(
for hostnames
)
kindex(indexes, completion tag)
item(tt(indexes))(
used for array indexes
)
kindex(jobs, completion tag)
item(tt(jobs))(
used for jobs
)
kindex(keymaps, completion tag)
item(tt(keymaps))(
for names of zsh keymaps
)
kindex(keysyms, completion tag)
item(tt(keysyms))(
for names of X keysyms
)
kindex(libraries, completion tag)
item(tt(libraries))(
for names of system libraries
)
kindex(limits, completion tag)
item(tt(limits))(
for system limits
)
kindex(local-directories, completion tag)
item(tt(local-directories))(
for names of directories which are subdirectories of the current working
directory when completing for the tt(cd) and related builtin commands
)
kindex(manuals, completion tag)
item(tt(manuals))(
for names of manual pages
)
kindex(maps, completion tag)
item(tt(maps))(
for map names (e.g. NIS maps)
)
kindex(messages, completion tag)
item(tt(messages))(
used to look up the tt(format) style for messages
)
kindex(modifiers, completion tag)
item(tt(modifiers))(
for names of X modifiers
)
kindex(modules, completion tag)
item(tt(modules))(
for modules (e.g. tt(zsh) modules)
)
kindex(my-accounts, completion tag)
item(tt(my-accounts))(
used to look up the tt(users-hosts) style
)
kindex(named-directories, completion tag)
item(tt(named-directories))(
for named directories (you wouldn't have guessed that, would you?)
)
kindex(names, completion tag)
item(tt(names))(
for all kinds of names
)
kindex(nicknames, completion tag)
item(tt(nicknames))(
for nicknames of NIS maps
)
kindex(options, completion tag)
item(tt(options))(
for command options
)
kindex(original, completion tag)
item(tt(original))(
used by the tt(_approximate), tt(_correct) and tt(_expand) completers when
adding the original string
)
kindex(other-accounts, completion tag)
item(tt(other-accounts))(
used to look up the tt(users-hosts) style
)
kindex(packages, completion tag)
item(tt(packages))(
for packages (e.g. tt(rpm) or installed tt(Debian) packages)
)
kindex(parameters, completion tag)
item(tt(parameters))(
for names of parameters
)
kindex(path-directories, completion tag)
item(tt(path-directories))(
for names of directories found by searching the tt(cdpath) array when
completing for the tt(cd) and related builtin commands
)
kindex(paths, completion tag)
item(tt(paths))(
used to look up the values of the tt(expand), tt(ambiguous) and
tt(special-dirs) styles
)
kindex(pods, completion tag)
item(tt(pods))(
for perl pods (documentation files)
)
kindex(ports, completion tag)
item(tt(ports))(
for communication ports
)
kindex(prefixes, completion tag)
item(tt(prefixes))(
for prefixes (like those of a URL)
)
kindex(printers, completion tag)
item(tt(printers))(
for printer names
)
kindex(processes, completion tag)
item(tt(processes))(
for process identifiers
)
kindex(processes-names, completion tag)
item(tt(processes-names))(
used to look up the tt(command) style when generating the names of
processes for tt(killall)
)
kindex(sequences, completion tag)
item(tt(sequences))(
for sequences (e.g. tt(mh) sequences)
)
kindex(sessions, completion tag)
item(tt(sessions))(
for sessions in the tt(zftp) function suite
)
kindex(signals, completion tag)
item(tt(signals))(
for signal names
)
kindex(strings, completion tag)
item(tt(strings))(
for strings (e.g. the replacement strings for the tt(cd) builtin
command)
)
kindex(styles, completion tag)
item(tt(styles))(
for styles used by the zstyle builtin command
)
kindex(tags, completion tag)
item(tt(tags))(
for tags (e.g. tt(rpm) tags)
)
kindex(targets, completion tag)
item(tt(targets))(
for makefile targets
)
kindex(types, completion tag)
item(tt(types))(
for types of whatever (e.g. address types for the tt(xhost) command)
)
kindex(urls, completion tag)
item(tt(urls))(
used to look up the tt(urls) and tt(local) styles when completing URLs
)
kindex(users, completion tag)
item(tt(users))(
for usernames
)
kindex(values, completion tag)
item(tt(values))(
when completing a value out of a set of values (or a list of such
values)
)
kindex(version, completion tag)
item(tt(version))(
used by tt(_call_program) to look up the command to run to determine the installed
version of various other commands (such as tt(diff) and tt(make)).
)
kindex(warnings, completion tag)
item(tt(warnings))(
used to look up the tt(format) style for warnings
)
kindex(widgets, completion tag)
item(tt(widgets))(
for zsh widget names
)
kindex(windows, completion tag)
item(tt(windows))(
for IDs of X windows
)
kindex(zsh-options, completion tag)
item(tt(zsh-options))(
for shell options
)
enditem()

subsect(Standard Styles)
cindex(completion system, styles)

Here are the names of the styles used by the completion system.  Note
that the values of several of these styles represent boolean
values; here, any of the strings `tt(true)', `tt(on)',
`tt(yes)', and `tt(1)' can be used for the truth value `true' and
the strings `tt(false)', `tt(off)', `tt(no)', and `tt(0)' are
interpreted as `false'.  The behavior for any other value is undefined 
unless the description for the particular style mentions other
possible values; in particular, the default value may be either on or off
if the style is not set.

Some of these styles are tested for every tag used to add possible
matches and for the tt(default) tag (most notably tt(menu),
tt(list-colors) and the styles controlling the completion listing like 
tt(list-packed) and tt(last-prompt)). When tested for the tt(default)
tag, only the var(function) field of the context will be set up, so
the default value will normally be set like:

example(zstyle ':completion:*:default' menu ...)

startitem()
kindex(accept-exact, completion style)
item(tt(accept-exact))(
This is tested for the default tag and the tags used when generating
matches.  If it is set to `true' for at least one match which is the
same as the string on the line, this match will immediately be
accepted.

When completing pathnames (where it is looked up for the tt(paths)
tag), this style also accepts any number of patterns as the value. If
this is used, pathnames matching one of these patterns will be
accepted immediately even if the command line contains some more
partially typed pathname components and these match no file under the
directory accepted.

Note that this is also used by the tt(_expand) completer to decide if
words beginning with a tilde or parameter expansion should be
expanded. This means that if, for example, there are parameters
tt(foo) and tt(foobar), the string `tt($foo)' will only be expanded if 
tt(accept-exact) is set to `true'.
)
kindex(add-space, completion style)
item(tt(add-space))(
This style is used by the tt(_expand) completer.  If it is `true' (the
default), a space will be inserted after all words resulting from the 
expansion (except for directory names which get a slash).  The value
may also be the string `tt(file)' to make the completer add a space
only to names of existing files.  Finally, the `true' values and
`tt(file)' may be combined with `tt(subst)' to keep the completer from 
adding a space when the resulting words were generated by expanding a
substitution of the form `tt($LPAR()...RPAR())' or `tt(${...})'.

It is also used by the tt(_prefix) completer as a simple boolean value
to decide if a space should be inserted before the suffix.
)
kindex(ambiguous, completion style)
item(tt(ambiguous))(
This applies when completing non-final components of filename paths.
If it is set, the cursor is left after the first ambiguous component, even
if menu completion is in use.  It is tested with the tt(paths) tag.
)
kindex(assign-list, completion style)
item(tt(assign-list))(
When completing after an equals sign, the completion system normally
completes only one filename.  In some cases, particularly for certain
parameters such as tt(PATH), a list of filenames separated by colons is
required.  This style can be set to a list of patterns matching the names
of such parameters.

The default is to complete lists when the word on the line already
contains a colon.
)
kindex(auto-description, completion style)
item(tt(auto-description))(
If set, this style's value will be used as the description for options which
are not described by the completion functions, but that have exactly
one argument.  The sequence `tt(%d)' in the value will be replaced by
the description for this argument.  Depending on personal preferences,
it may be useful to set this style to something like `tt(specify: %d)'. 
Note that this may not work for some commands.
)
kindex(avoid-completer, completion style)
item(tt(avoid-completer))(
This is used by the tt(_all_matches) completer to decide if the string 
consisting of all matches should be added to the list currently being
generated.  Its value is a list of names of completers.  If any of
these is the name of the completer that generated the matches in this
completion, the string will not be added.

The default value for this style is `tt(_expand _old_list _correct
_approximate)', i.e. it contains the completers for which a string
with all matches will almost never be wanted.
)
kindex(cache-path, completion style)
item(tt(cache-path))(
This style defines the path where any cache files containing dumped
completion data are stored.  Defaults to `tt($ZDOTDIR/.zcompcache)', or
`tt($HOME/.zcompcache)' if tt($ZDOTDIR) is not defined.  The completion
layer will not be used unless the tt(use-cache) style is set.
)
kindex(call-command, completion style)
item(tt(call-command))(
Currently this is only used by the function completing tt(make)
targets.  If it is set to `true' and the installed version of the
tt(make) command allows it, tt(make) is called in a way to generate
all possible targets.  The default value of this style is `false'
because calling tt(make) can potentially take a very long time and in
some cases may even cause actions from the makefile be executed
despite the options given to tt(make).
)
kindex(command, completion style)
item(tt(command))(
In many places, completion functions need to call external commands to
generate the list of completions.  This style can be used to override the
command which is called in some such cases.  The elements of the value are
joined with spaces to form a command line to execute.  The value can also
start with a hyphen, in which case the usual command will be added to the
end; this is most useful for putting `tt(builtin)' or `tt(command)' in
front to make sure the appropriate version of a command is called, for
example to avoid calling a shell function with the same name as an external
command.

As an example, the function generating process IDs as matches uses this
style with the tt(processes) tag to generate the IDs to complete and
the list of processes to display (if the tt(verbose) style is `true').
The list produced by the command should look like the output of the
tt(ps) command.  The first line is not displayed, but is searched for
the string `tt(PID)' (or `tt(pid)') to find the position of the
process IDs in the following lines.  If the line does not contain
`tt(PID)', the first numbers in each of the other lines are taken as the 
process IDs to complete.

Note that the completion function generally has to call the command
every time it is called.  Because of that care should be taken to
specify only commands that take a short time to run (and that will
eventually stop at all).
)
kindex(commands, completion style)
item(tt(commands))(
This is used by the function completing sub-commands for the system
initialisation scripts (residing in tt(/etc/init.d) or somewhere not
too far away from that).  It's values give the default commands to
complete for those commands for which the completion function isn't
able to find them out automatically.  The default for this style are
the two strings `tt(start)' and `tt(stop)'.
)
kindex(complete, completion style)
item(tt(complete))(
This is used by the tt(_expand_alias) function when invoked as a
bindable command.  If it set to `true' and the word on the command
line is not the name of an alias, matching alias names will be
completed.
)
kindex(completer, completion style)
item(tt(completer))(
The strings given as the value of this style provide the names of the
completer functions to use. The available completer functions are
described in
ifzman(the section `Control Functions' below)\
ifnzman(noderef(Control Functions))\
.

Each string may be the name of a completer function or a string of the 
form `var(function)tt(:)var(name)'. In the first case the
var(completer) field of the context will contain the name of the
completer without the leading underscore and with all other
underscores replaced by hyphens.  In the second case the
var(function) is the name of the completer to call, but the context
will contain the var(name) in the var(completer) field of the
context.  If the var(name) starts with a hyphen, the string for the
context will be build from the name of the completer function as in
the first case with the var(name) appended to it.  For example: 

example(zstyle ':completion:*' completer _complete _complete:-foo)

Here, completion will call the tt(_complete) completer twice, once
using `tt(complete)' and once using `tt(complete-foo)' in the
var(completer) field of the context.  Normally, using the same
completer more than once makes only sense when used with the
`var(functions)tt(:)var(name)' form, because otherwise the context
name will be the same in all calls to the completer; possible
exceptions to this rule are the tt(_ignored) and tt(_prefix)
completers.

The default value for this style is tt(_complete _ignored),
i.e. normally only completion will be done, first using the
tt(ignored-patterns) style and the tt($fignore) array and then without 
ignoring matches.
)
kindex(condition, completion style)
item(tt(condition))(
This style is used by the tt(_list) completer function to decide if
insertion of matches should be delayed unconditionally. The default is 
`true'.
)
kindex(disabled, completion style)
item(tt(disabled))(
If this is set to `true', the tt(_expand_alias) completer and bindable 
command will try to expand disabled aliases, too.  The default is
`tt(false)'.
)
kindex(disable-stat, completion style)
item(tt(disable-stat))(
This is used with an empty tag by the function completing for the
tt(cvs) command to decide if the tt(zsh/stat) module should be used to
generate names of modified files in the appropriate places (this is its
only use).  If set, completion will use the tt(ls) command.
)
kindex(domains, completion style)
item(tt(domains))(
If set, gives the names of network domains that should be
completed.  If this is not set by the user domain names will be taken from
the file tt(/etc/resolv.conf).
)
kindex(expand, completion style)
item(tt(expand))(
This style is used when completing strings consisting of multiple
parts, such as path names.  If one of its values is
the string `tt(prefix)', the partially typed word from
the line will be expanded as far as possible even if trailing parts
cannot be completed.  If one of its values is the string `tt(suffix)',
matching names for
components after the first ambiguous one will also be added.  This
means that the resulting string is the longest unambiguous string
possible, but if menu completion is started on the list of matches
generated this way,
this will also cycle through the names of the files in pathname
components after the first ambiguous one.
)
kindex(fake-files, completion style)
item(tt(fake-files))(
This style is used when completing files and looked up 
without a tag.  Its values are of the form
`var(dir)tt(:)var(names...)'.  This will add the var(names) (strings
separated by spaces) as
possible matches when completing in the directory var(dir), even if no 
such files really exist.

This can be useful on systems that support special filesystems whose
top-level pathnames can not be listed or generated with glob patterns.
It can also be used for directories for which one does not have read
permission.
)
kindex(fake-parameters, completion style)
item(tt(fake-parameters))(
This is used by the completion function generating parameter names as
matches.  Its values are names of parameters which might not yet be
set, but which should be completed nonetheless.  Each name may also be 
followed by a colon and a string specifying the type of the parameter
(like `tt(scalar)', `tt(array)' or `tt(integer)').  If such a type is
given, the name will only be completed if parameters of that type are
requested in the particular context.  Names for which no type is
specified will always be completed.
)
kindex(file-patterns, completion style)
item(tt(file-patterns))(
In most places where filenames are completed, the function tt(_files)
is used which can be configured with this style.  If the style is
unset, tt(_files) offers, one after another, up to three tags:
`tt(globbed-files)',
`tt(directories)' and `tt(all-files)', depending on the types of files
expected by the caller of tt(_files).

If the tt(file-patterns) style is set, the default tags are not
used.  Instead, the value of the style says which tags and which
patterns are to be offered.  The strings in the value contain
specifications of the form
`var(pattern)tt(:)var(tag)'; each string may contain any number of
such specifications.  The var(pattern) gives a glob 
pattern that is to be used to generate
filenames.  If it contains the sequence `tt(%p)', that is replaced by
the pattern(s) given by the calling function.
Colons in the pattern must be preceded by a backslash to
make them distinguishable from the colon before the var(tag).  If more
than one pattern is needed, the patterns can be given inside braces,
separated by commas.  The
var(tag)s of all strings in the value will be offered by tt(_files)
(again, one after another) and used when looking up other styles.  For
strings containing more than one specification, the filenames for all
specifications will be generated at the same try.  If
no `tt(:)var(tag)' is given the `tt(files)' tag will be used.  The
var(tag) may also be
followed by an optional second colon and a description.  If that is
given, this description will be used for the `tt(%d)' in the value of
the tt(format) style (if that is set) instead of the default
description supplied by the completion function.  If the description
given here contains itself a `tt(%d)', that is replaced with the
description supplied by the completion function.

For example, to make the tt(rm) command first complete only names of
object files and the names of all files if no object file matches
the string on the line, one would do:

example(zstyle ':completion:*:*:rm:*' file-patterns \ 
    '*.o:object-files' '%p:all-files')

Another interesting example is to change the default behaviour that
makes completion first offer files matching the patterns given by the
calling function, then directories and then all files.  Many people 
prefer to get both the files matching the given patterns and the
directories in the first try and all files at the second try.  To
achieve this, one could do:

example(zstyle ':completion:*' file-patterns \ 
    '%p:globbed-files *(-/):directories' '*:all-files')

This works even for contexts in which all files would be completed,
because tt(_files) will not try a pattern more than once and it stops
when the pattern `tt(*)' was tried.

Note also that during the execution of completion functions, the
tt(EXTENDED_GLOB) option is in effect, so the characters `tt(#)',
`tt(~)' and `tt(^)' have special meanings in the patterns.
)
kindex(file-sort, completion style)
item(tt(file-sort))(
The completion function that generates filenames as possible matches
uses this style without a tag to determine in which order the 
names should be listed and completed when using menu completion.  The
value may be one of `tt(size)' to sort them by the size of the file,
`tt(links)' to sort them by the number of links to the file,
`tt(modification)' (or `tt(time)' or `tt(date)') to sort them by the last
modification time, `tt(access)' to sort them by the last access time, or
`tt(inode)' (or `tt(change)') to sort them by the last inode change
time.  If the style is set to any other value, or is unset, files will be
sorted alphabetically by name.  If the value contains the string
`tt(reverse)', sorting is done in decreasing order.
)
kindex(force-list, completion style)
item(tt(force-list))(
This forces a list of completions to be shown at any point where listing is
done, even in cases where the list would usually be suppressed.
For example, normally the list is only shown if
there are at least two different matches.  By setting this style to
`tt(always)', the list will always be shown, even if there is only a
single match which is immediately accepted.  The style may also
be set to a number.  In this case the list will be shown if there are
at least that many matches, even if they would all insert the same
string.

This style is tested for the default tag and all tags used when
generating matches. This allows one to turn unconditional listing on
for certain types of matches.
)
kindex(format, completion style)
item(tt(format))(
If this is set for the tt(descriptions) tag, its value is used as a
string to display above matches in completion lists.  The sequence
`tt(%d)' in this string will be replaced with a short description of
what these matches are.  This string may also contain the sequences to
specify output attributes, such as `tt(%B)', `tt(%S)' and
`tt(%{)...tt(%})'.

For the same purpose, this style is also tested with the tags used when
matches are generated before it is tested for the tt(descriptions)
tag.  This provides the possibility of defining different format
strings for different types of matches.

Note also that some completer functions define additional
`tt(%)'-sequences.  These are described for the completer functions that 
make use of them.

For the tt(messages) tag, this style defines a string used by some
completion functions to display messages.  Here, the `tt(%d)' is
replaced with a message given by the completion function.

Finally, when set with the tt(warnings) tag, the format string is
printed when no matches could be generated at all.  In this case the
`tt(%d)' is replaced with the descriptions for the matches that were
expected separated by spaces and the sequence `tt(%D)' is replaced with
those descriptions separated by newlines.

The `tt(%)' for the sequences that are replaced by strings provided by 
the completion functions like the `tt(%d)' may be followed by field
width specifications as  described for the tt(zformat) builtin command
from the tt(zsh/zutil) module, see
ifzman(zmanref(zshmodules))\
ifnzman(noderef(The zsh/zutil Module))\
.
)
kindex(glob, completion style)
item(tt(glob))(
This is used by the tt(_expand) completer.  If
it is set to `true' (the default), globbing will be attempted on the
words resulting from substitution (see the tt(substitute) style) or
the original string from the line.
)
kindex(global, completion style)
item(tt(global))(
If this is set to `true' (the default), the tt(_expand_alias)
completer and bindable command will try to expand global aliases.
)
kindex(group-name, completion style)
item(tt(group-name))(
The completion system can put different types of matches in different
groups which are then displayed separately in the list of possible
completions.  This style can be used to give the names for these groups
for particular tags.  For example, in command position the completion
system generates names of builtin and external commands, names of
aliases, shell functions and parameters and reserved words as possible
completions.  To have the external commands and shell functions listed
separately, one can set:

example(zstyle ':completion:*:*:-command-:*:commands' group-name commands
zstyle ':completion:*:*:-command-:*:functions' group-name functions)

This also means that if the same name is used for different types of
matches, then those matches will be displayed together in the same
group.

If the name given is the empty string, then the name of the tag for
the matches will be used as the name of the group. So, to have all
different types of matches displayed separately, one can just set:

example(zstyle ':completion:*' group-name '')

All matches for which no group name is defined will be put in a group
named tt(-default-).
)
kindex(group-order, completion style)
item(tt(group-order))(
This style is to be used together with the tt(group-name) style.  Once
different types of matches are put into different groups, this style
can be used to define in which order these groups should appear when listing 
(compare tt(tag-order), which determines which completions appear at
all).  The strings in the value are taken as group names and the named
groups will be shown in the order in which their names appear in the
value.  All groups whose names are not given in the value of this style 
will appear in the order defined by the function generating the
matches.

For example, to have names of builtin commands, shell functions and
external commands appear in this order when completing in command
position one would set:

example(zstyle ':completion:*:*:-command-:*' group-order \ 
       builtins functions commands)
)
kindex(groups, completion style)
item(tt(groups))(
A style holding the names of the groups that should be completed. If
this is not set by the user, the group names from the YP database or
the file `tt(/etc/group)' will be used.
)
kindex(hidden, completion style)
item(tt(hidden))(
If this is set to one of the `true' values, the matches for the tags
for which this is set will not appear in the list; only the
description for the matches as set with the tt(format) style will be
shown.  If this is set to `tt(all)', not even the description will be
displayed.

Note that the matches will still be completed; they are just not shown 
in the list.  To avoid having matches considered as possible
completions at all, the tt(tag-order) style can be modified as described
below.
)
kindex(hosts, completion style)
item(tt(hosts))(
A style holding the names of hosts that should be completed. If this
is not set by the user the hostnames in `tt(/etc/hosts)' will be used.
)
kindex(hosts-ports, completion style)
item(tt(hosts-ports))(
This style is used by commands that need or accept hostnames and
ports.  The strings in the value should be of the form
`var(host)tt(:)var(port)'.  These hostnames and ports are completed
depending on the information already on the line, so that if, for
example, the hostname is already typed, only those ports specified for that
host will be completed.  Multiple ports for the same host may appear.
)
kindex(ignore-line, completion style)
item(tt(ignore-line))(
This style is tested for the tags used when generating matches.  If it
is set to `true', then none of the words that are already on the line
will be considered possible completions.  If it is set to
`tt(current)', the word the cursor is on will not be considered a
possible completion.  The same happens if the value is
`tt(current-shown)', but only if the list of completions is currently
shown on the screen.  Finally, if it is set to `tt(other)' all words
except the current one will not be considered to be a possible
completion.

The values `tt(current)' and `tt(current-shown)' are a bit like the
opposite of tt(accept-exact). They mean that only strings with
missing characters will be completed.

Note that you almost certainly don't want to set this to `true' or
`tt(other)' for a general
context such as `tt(:completion:*)'.  This is because it would disallow
completion of, for example, options multiple times even if the command
in question accepts the option more than once.
)
kindex(ignore-parents, completion style)
item(tt(ignore-parents))(
The style is tested by the function completing pathnames without a tag to
determine whether to ignore
the names of directories already mentioned in the current word, or the
name of the current working directory.  The value must include one or both
of the following strings:

startitem()
item(tt(parent))(
The name of any directory whose path is already contained in the word on
the line is ignored.  For example, when completing after tt(foo/../), the
directory tt(foo) will not be considered a valid completion.
)
item(tt(pwd))(
The name of the current working directory will not be completed, so that,
for example, completion after tt(../) will not use the name of the current
directory.
)
enditem()

In addition, the value may include one or both of:

startitem()
item(tt(..))(
Ignore the specified directories only when the word on the line contains
the substring `tt(../)'.
)
item(tt(directory))(
Ignore only when names of directories are completed, not when completing
names of files.
)
enditem()

Note that names of directories ignored because of one of the tests
will be ignored in the same way as the matches ignored because of the
tt(ignored-patterns) style.  I.e., by using the tt(_ignored) completer
it is possible to complete these directories nonetheless.
)
kindex(ignored-patterns, completion style)
item(tt(ignored-patterns))(
This style can be used to specify a list of patterns which are tested
against against the trial completions in a given context; any matching
completions will be removed from the list of possibilities.  The
tt(_ignored) completer can appear in the list of completers to produce a
list which includes these matches once more.  This is a more configurable
version of the shell parameter tt($fignore).

Note that during the execution of completion functions, the
tt(EXTENDED_GLOB) option is in effect, so the characters `tt(#)',
`tt(~)' and `tt(^)' have special meanings in the patterns.
)
kindex(insert-ids, completion style)
item(tt(insert-ids))(
When completing process IDs, for example as arguments to the tt(kill) and
tt(wait) builtins, completion allows the user to type the name of a
command, which will be converted to the appropriate process ID.  A problem
arises when the process name typed is not unique.  By default (or if this
style is set explicitly to `tt(menu)') the name will be converted
immediately to a set of possible IDs, and menu completion will be started
to cycle through them.  If the value of the style is `tt(single)', however,
the shell will wait until the user has typed enough to make the command
unique before converting the name to an ID; the user must type any
additional characters required.  If the value is any other string, menu
completion will be started when the string typed by the user is longer than
the common prefix of the corresponding IDs.
)
kindex(insert-tab, completion style)
item(tt(insert-tab))(
If this has one of the `true' values, the completion system will
insert a TAB character (assuming it was used to start completion) instead
of performing completion when there is no non-blank character to the left
of the cursor.  If set to `false', completion will be done even there.

The value may also contain the substrings `tt(pending)' or
`tt(pending=)var(val)' to make the character typed to start completion 
be inserted instead of completion being tried when there is input
pending which has not yet been processed by the shell. If a var(val)
is given, completion will not be done if there are at least that many
characters of unprocessed input. This is often useful to have set when 
pasting characters into a terminal. Note however, that it relies on
the tt($PENDING) special parameter from the tt(zsh/zle) module being set
properly which is not guaranteed on all platforms.

The default value of this style is `true' unless when completing
inside the tt(vared) builtin command, where it defaults to `false'.
)
kindex(insert-unambiguous, completion style)
item(tt(insert-unambiguous))(
This is used by the tt(_match) and tt(_approximate) completer
functions, where the possible completions may not have a common prefix so
that menu completion is often the most useful may of choosing completions.
If the style is set to `true', the completer will start menu
completion only if no unambiguous string could be generated that is at
least as long as the original string typed by the user.  Note that the
tt(_approximate) completer uses it after setting the completer field
in the context name to one of tt(correct-)var(num) or
tt(approximate-)var(num), where var(num) is the number of errors that
were accepted.

When used for the tt(_match) completer, the style may also be set to
the string `tt(pattern)'.  This makes the pattern on the line be left
unchanged if it didn't match unambiguously.
)
kindex(keep-prefix, completion style)
item(tt(keep-prefix))(
This style is used by the tt(_expand) completer.  If it is `true', the
completer will try to keep a prefix containing a tilde or parameter
expansion.  I.e., the string `tt(~/f*)' would be expanded to
`tt(~/foo)' instead of `tt(/home/user/foo)'.  If the style is set to
`tt(changed)' (the default), the prefix will only be left unchanged if
there were other changes between the expanded words and the original
word from the command line.  Any other value makes the prefix be
expanded unconditionally.

Note that with one of the `true' values, the tt(_expand) completer
returns if there is only one expansion and that is, after restoring
the original prefix, the same as the original word.  This means that
other completers will be called immediately after tt(_expand).
)
kindex(last-prompt, completion style)
item(tt(last-prompt))(
This is used to determine if the completion code should try to put the
cursor back onto the previous command line after showing a completion
listing (as for the tt(ALWAYS_LAST_PROMPT) option).  As with several other
styles, it is tested for the tt(default) tag as well as all the possible
tags when generating matches.  The cursor will be moved back to the
previous line if this style is `true' for all types of matches added.  Note
also that this is independent of the numeric argument, unlike the
tt(ALWAYS_LAST_PROMPT) option.
)
kindex(list, completion style)
item(tt(list))(
This style is used by the tt(_history_complete_word) bindable command.
If it is set to `true' it has no effect, but if it is set to `false'
the matches will not be listed, overriding the setting of the options
that control listing behaviour, especially tt(AUTO_LIST). Use the
context prefix `tt(:completion:history-words)'.
)
kindex(list-colors, completion style)
item(tt(list-colors))(
If the tt(zsh/complist) module is used, this style can be used to set
color specifications as with the tt(ZLS_COLORS) and tt(ZLS_COLOURS)
parameters, which will not be honored under this completion system (see
ifzman(the section `The zsh/complist Module' in zmanref(zshmodules))\
ifnzman(noderef(The zsh/complist Module))\
).

If this style is set for the tt(default) tag, the strings in the value 
are taken as specifications that are to be used everywhere.  If it is
set for other tags, the specifications are used only for matches of
the type described by the tag.  For this to work best, the tt(group-name)
style must be set to an empty string.  If the tt(group-name) tag
specifies other names for the groups the matches in these groups can
be colored by using these names together with the `tt((group)...)'
syntax described for the tt(ZLS_COLORS) and tt(ZLS_COLOURS) parameters 
and adding the specifications to the value for this style with the
tt(default) tag (although in most cases it should work by setting this 
style for the appropriate tags).

It is possible to use the same specifications set up for the GNU
version of the tt(ls) command:

example(zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS})

The default colors are the same as for the GNU tt(ls) command and can be
obtained by setting the style to an empty string (i.e. tt('')).
)
kindex(list-packed, completion style)
item(tt(list-packed))(
Like the tt(list-colors) style, this is tested with the tt(default)
tag and all tags used when generating matches.  If it is set to `true'
for a tag, the matches added for it will be listed as if the
tt(LIST_PACKED) option were set.  If it is set to `false',
they are listed normally.
)
kindex(list-prompt, completion style)
item(tt(list-prompt))(
If this style is set for the tt(default) tag,
completion lists that don't fit on the screen can be scrolled (see
ifzman(the description of the tt(zsh/complist) module in zmanref(zshmodules))\
ifnzman(noderef(The zsh/complist Module))\
).  The value, if not the empty string, will be displayed after every
screenful and the shell will prompt for a key press; if the style is
set to the empty string,
a default prompt will be used.  The value may contain the escape sequences
`tt(%l)' or `tt(%L)', which will be replaced by the number of the last line
displayed and the total number of lines; `tt(%m)' or `tt(%M)', which will
be replaced by the number of the  last match shown and the total number of
matches; and `tt(%p)' and `tt(%P)', which will be replaced by `tt(Top)'
when at the beginning of the list, `tt(Bottom)' when at the end and the
position shown in percent of the total length otherwise.  In each of these
cases the form with the uppercase letter is replaced by a string of fixed
width, padded to the  right with spaces.  As in other prompt strings, the
escape sequences `tt(%S)', `tt(%s)', `tt(%B)', `tt(%b)', `tt(%U)',
`tt(%u)', and `tt(%{)...tt(%})' for entering and leaving the display modes
standout, bold and underline are also available.
)
kindex(list-rows-first, completion style)
item(tt(list-rows-first))(
This style is tested in the same way as the tt(list-packed) style and
determines if matches are to be listed in a rows-first fashion, as for the
tt(LIST_ROWS_FIRST) option.
)
kindex(list-suffixes, completion style)
item(tt(list-suffixes))(
This style is used by the function used to complete filenames.  If
completion is attempted on a string containing multiple partially
typed pathname components and this style is set to `true', all
components starting with the first one for which more than one match
could be generated will be shown.
)
kindex(local, completion style)
item(tt(local))(
This style is used by completion functions which generate URLs as
possible matches to add suitable matches when a URL points to a
local web server, that is, one whose files are available directly on the
local file system.  Its value should consist of three strings: a
hostname, the path to the default web pages for the server and the
directory name used by a user placing web pages within their home
area.  For example, completion after `tt(http://toast/~yousir/)' will
attempt to match the name `tt(toast)' against the first argument to the
style, and if successful will look in the directory under tt(~yousir) given
by the third argument to the style for possible completions.
)
kindex(match-original, completion style)
item(tt(match-original))(
This is used by the tt(_match) completer.  If it is set to
tt(only), tt(_match) will try to generate matches without inserting a
`tt(*)' at the cursor position.  If set to any other non-empty value,
it will first try to generate matches without inserting the `tt(*)'
and if that yields no matches, it will try again with the `tt(*)'
inserted.  If it is unset or set to the empty string, matching will
only be done with the `tt(*)' inserted.
)
kindex(matcher, completion style)
item(tt(matcher))(
This style is tested for tags used when generating matches.  Its value
is used as an match specification additional to any given by the
tt(matcher-list) style which should be in the form described in
ifzman(the section `Matching Control' in zmanref(zshcompwid))\
ifnzman(noderef(Matching Control))\
.
)
kindex(matcher-list, completion style)
item(tt(matcher-list))(
This style is used by the main completion function to retrieve match
specifications that are to be used everywhere.  Its value should be a
list of such specifications.  The completion system will try them one
after another for each completer selected. For example, to first try
simple completion and, if that generates no matches, case-insensitive
completion one would do:

example(zstyle ':completion:*' matcher-list '' 'm:{a-zA-Z}={A-Za-z}')

By default every specification replaces previous ones. If specification
is prefixed with tt(+), it is added to the existing list. This allows
testing more general patterns without repeating the whole list every
time, as in:

example(zstyle ':completion:*' matcher-list '' '+m{a-Z}={A-Z}' '+m{A-Z}={a-z}')

The style allows even finer control by specifying a particular completer,
without the leading underscore, in the third field of the completion
context.  For example, if one uses the completers tt(_complete) and
tt(_prefix) but wants to try case-insensitive completion only when using
the tt(_complete) completer, one would do:

example(zstyle ':completion:*' completer _complete _prefix
zstyle ':completion:*:complete:*' matcher-list \ 
       '' 'm:{a-zA-Z}={A-Za-z}')

Note that the tt(completer) style allows user-defined names to 
be used in the context instead of the name of the completer.
This is useful if, for example, one wants to try
normal completion without a match specification and with
case-insensitive matching first, correction if that doesn't generate
any matches and partial-word completion if that doesn't yield any
matches either.  In this case one can give the tt(_complete)
completer more than once in the tt(completer) style and define different
match specifications for each occurrence, as in:

example(zstyle ':completion:*' completer _complete _correct _complete:foo
zstyle ':completion:*:complete:*' matcher-list \ 
    '' 'm:{a-zA-Z}={A-Za-z}'
zstyle ':completion:*:foo:*' matcher-list \ 
    'm:{a-zA-Z}={A-Za-z} r:|[-_./]=* r:|=*')

If the style is unset in any context no match specification is applied;
further, some completers such as tt(_correct) and tt(_approximate) do not
use the match specifications at all.  However, it is always safe
to use the simple form for this style (as in the first example above),
since any completers which do not use match specifications will only ever
be called once, rather than once per specification.

Since the specification-strings in this style have to be tried one after
another, it is a good idea to keep their number low.  In most cases
one to three strings (each of which may, without to large a performance 
hit, consist of more than one single match specification) will give
acceptable performance.
)
kindex(max-errors, completion style)
item(tt(max-errors))(
This is used by the tt(_approximate) and tt(_correct) completer functions
to determine the maximum number of errors to allow.  The completer will try
to generate completions by first allowing one error, then two errors, and
so on, until either a match or matches were found or the maximum number of
errors given by this style has been reached.

If the value for this style contains the string `tt(numeric)', the 
completer function will take any numeric argument as the
maximum number of errors allowed. For example, with

example(zstyle ':completion:*:approximate:::' max-errors 2 numeric)

two errors are allowed if no numeric argument is given, but with
a numeric argument of six (as in `tt(ESC-6 TAB)'), up to six
errors are accepted.  Hence with a value of `tt(0 numeric)', no correcting
completion will be attempted unless a numeric argument is given.

If the value contains the string `tt(not-numeric)', the completer
will em(not) try to generate corrected
completions when given a numeric argument, so in this case the number given
should be greater than zero.  For example, `tt(2 not-numeric)' specifies that
correcting completion with two errors will usually be performed, but if a
numeric argument is given, correcting completion will not be
performed.

The default value for this style is `tt(2 numeric)'.
)
kindex(menu, completion style)
item(tt(menu))(
If this is set to true in a given context, using any of the tags defined
for a given completion, menu completion will be used.  The tag
`tt(default)' can be used to set the default value, but a specific tag will take
precedence.  If none of the values found in this way is true but at least
one is set to `tt(auto)' the behaviour will be as for the tt(AUTO_MENU)
option.  Finally, if one of the values is explicitly set to false, menu
completion will be turned off even if it would otherwise be active (for
example, with the tt(MENU_COMPLETE) option).

Using the form `tt(yes=)var(num)', where `tt(yes)' may be any of the
true values (`tt(yes)', `tt(true)', `tt(on)' and `tt(1)') turns on
menu completion if there at least var(num) matches.  Using this for one
of the `false' values (as in `tt(no=10)') makes menu completion
em(not) be used if there are var(num) or more matches.  Of course,
this is only useful when menu completion is normally used, e.g. by
setting the tt(MENU_COMPLETE) option.  The `true' values may also be
used in the form `tt(yes=long)' to turn on menu completion
if the list does not fit onto the screen.  This will start menu
completion only if normal completion was attempted, not when only the
list of possible completions was requested.  To start menu completion
even then, the value `tt(yes=long-list)' can be used.

In addition to (or instead of) the above possibilities, the value may
contain the string `tt(select)', optionally followed by an equals sign and a
number.  In this case menu selection (as defined by the tt(zsh/complist)
module) will be started.  Without the optional number, it will be started
unconditionally and with a number it will be started only if at least that
many matches are generated; if the values for more than one tag provide a
number, the smallest number is taken.  Menu selection can be turned off
explicitly by defining a value containing the string `tt(no-select)'.

It is also possible to start menu selection only if the list of
matches does not fit on the screen by using the value
`tt(select=long)'.  This will only start menu selection if the widget
invoked does completion, not simply listing as done by
tt(delete-char-or-list); to start menu selection even here, use the value
`tt(select=long-list)'.

To turn on menu completion or menu selection when a certain number of
matches is generated em(or) the list of matches does not fit onto the
screen, both of `tt(yes=)' and `tt(select=)' can be given twice, once
with a number and once with `tt(long)' or `tt(long-list)'.
)
kindex(numbers, completion style)
item(tt(numbers))(
This is used with the tt(jobs) tag.  If it is `true', the shell will
complete the job numbers instead of the shortest unambiguous strings
of the jobs' command lines.  If the value is a number, job numbers will
only be used if that many words from the job descriptions are required to
resolve ambiguities.  For example, if the value is `tt(1)', strings will
only be used if all jobs differ in the first word on their command lines.
)
kindex(old-list, completion style)
item(tt(old-list))(
This is used by the tt(_oldlist) completer.  If it is set to `tt(always)',
then standard widgets which perform listing will retain the current list of
matches, however they were generated; this can be turned off explicitly
with the value `tt(never)', giving the behaviour without the tt(_oldlist)
completer.  If the style is unset, or any other value, then the existing
list of completions is displayed if it is not already; otherwise, the
standard completion list is generated; this is the default behaviour of
tt(_oldlist).  However, if there is an old list and this style contains
the name of the completer function that generated the list, then the
old list will be used even if it was generated by a widget which does
not do listing.

For example, suppose you type tt(^Xc) to use the tt(_correct_word)
widget, which generates a list of corrections for the word under the
cursor.  Usually, typing tt(^D) would generate a standard list of
completions for the word on the command line, and show that.  With
tt(_oldlist), it will instead show the list of corrections already
generated.

As another example consider the tt(_match) completer: with the
tt(insert-unambiguous) style set to `true' it inserts only a common prefix
string, if there is any.  However, this may remove parts of the original
pattern, so that further completion could produce more matches than on the
first attempt.  By using the tt(_oldlist) completer and setting this style
to tt(_match), the list of matches generated on the first attempt will be
used again.
)
kindex(old-matches, completion style)
item(tt(old-matches))(
This is used by the tt(_all_matches) completer to decide if an old
list of matches should be used if one exists.  It may be set to one of 
the `true' values or to the string `tt(only)' to use such a list.  If
it is set to `tt(only)', tt(_all_matches) will only use an old list
and won't have any effect on the list of matches currently being
generated.
)
kindex(old-menu, completion style)
item(tt(old-menu))(
This is used by the tt(_oldlist) completer.  It controls how menu
completion behaves when a completion has already been inserted and the
user types a standard completion key type such as tt(TAB).  The default
behaviour of tt(_oldlist) is that menu completion always continues
with the existing list of completions.  If this style is set to
`false', however, a new completion is started if the old list was
generated by a different completion command; this is the behaviour without
the  tt(_oldlist) completer.

For example, suppose you type tt(^Xc) to generate a list of corrections,
and menu completion is started in one of the usual ways.  Usually, or with
this style set to tt(false), typing tt(TAB) at this point would start
trying to complete the line as it now appears.  With tt(_oldlist), it
instead continues to cycle through the list of corrections.
)
kindex(original, completion style)
item(tt(original))(
This is used by the tt(_approximate) and tt(_correct)
completers to decide if the original string should be added as
one possible completion.  Normally, this is done only if there are
at least two possible corrections, but if this style is set to `true', it
is always added.  Note that these completers use this style after
setting the completer field in the context name to
tt(correct-)var(num) or tt(approximate-)var(num), where var(num) is
the number of errors that were accepted.
)
kindex(packageset, completion style)
item(tt(packageset))(
This style is used when completing arguments of the Debian `tt(dpkg)'
program.  It contains an override for the default package set
for a given context.  For example,

example(zstyle ':completion:*:complete:dpkg:option--status-1:*' \ 
               packageset avail)

causes available packages, rather than only installed packages,
to be completed for `dpkg --status'.
)
kindex(path, completion style)
item(tt(path))(
The function that completes color names uses this style with the 
tt(colors) tag.  The value should be the pathname of a file
containing color names in the format of an X11 tt(rgb.txt) file.  If
the style is not set but this file is found in one of various standard
locations it will be used as the default.
)
kindex(ports, completion style)
item(tt(ports))(
A style holding the service names of ports to complete.  If this is
not set by the user, the service names from `tt(/etc/services)' will
be used.
)
kindex(prefix-hidden, completion style)
item(tt(prefix-hidden))(
This is used when matches with a common prefix are added (e.g. option
names).  If it is `true', this prefix will not be shown in the list of
matches.

The default value for this style is `false'.
)
kindex(prefix-needed, completion style)
item(tt(prefix-needed))(
This, too, is used for matches with a common prefix.  If it is set to
`true' this common prefix has to be typed by the user to generate the
matches.  E.g. for options this means that the `tt(-)', `tt(+)', or
`tt(-)tt(-)' has to be on the line to make option names be completed at
all.

The default style for this style is `true'.
)
kindex(preserve-prefix, completion style)
item(tt(preserve-prefix))(
This style is used when completing path names.  Its value should be a
pattern matching an initial prefix of the word to complete that should
be left unchanged under all circumstances.  For example, on some Unices
an initial `tt(//)' (double slash) has a special meaning and hence
should be kept.  For that one could set this style to the string
`tt(//)'.  As another example, setting this style to `tt(?:/)' under
Cygwin would allow completion after `tt(a:/...)' and the like.
)
kindex(range, completion style)
item(tt(range))(
This is used by the tt(_history) completer and the
tt(_history_complete_word) bindable command to decide which words
should be completed.  It may be set to a number, var(N), to say that
only the last var(N) words from the history should be completed.  The
value may also be of the form `var(max)tt(:)var(slice)'.  This means
that first the last var(slice) words will be completed.  If that
yields no matches, the var(slice) words before those will be tried and 
so on, until either at least one match is generated or var(max) words
have been tried.  The default is to complete all words from the
history at once.
)
kindex(regular, completion style)
item(tt(regular))(
This style is used by the tt(_expand_alias) completer and bindable 
command.  If set to `true' (the default), regular aliases will be
expanded but only in command position.  If it is set to `false', regular
aliases will never be expanded and if it is set to the string
`tt(always)', regular aliases will be expanded even if not in command
position.
)
kindex(remove-all-dups, completion style)
item(tt(remove-all-dups))(
The tt(_history_complete_word) bindable command and the tt(_history)
completer use this to decide if all duplicate matches should be
removed, rather than just consecutive duplicates.
)
kindex(select-prompt, completion style)
item(tt(select-prompt))(
If this is set for the tt(default) tag, its
value will be displayed during menu selection (see the tt(menu) style
above) when the completion list does not fit on the screen as a
whole.  The same escapes as for the tt(list-prompt) style are
understood, but give the number of the match or line the mark is
on.  A default prompt is used when the value is the empty string.
)
kindex(select-scroll, completion style)
item(tt(select-scroll))(
This style is tested for the tt(default) tag and determines how a
completion list is scrolled during a menu selection (see the tt(menu)
style above) when the completion list does not fit on the screen as a
whole.  Its value should be `tt(0)' (zero) to scroll by
half-screenfuls, a positive integer to scroll by that many lines and a
negative number to scroll by the number of lines of the screen minus
that number (or plus the number, since it is negative).  The default is to
scroll by single lines.
)
kindex(single-ignored, completion style)
item(tt(single-ignored))(
This is used by the tt(_ignored) completer.  It specifies what
should be done if it can generate only one match, which is often a
special case.  If its value is `tt(show)', the single match will be
displayed but not inserted.  If the value is `tt(menu)', then the single
match and the original string are both added as matches and menu completion
is started so that one can easily select either of them.
)
kindex(sort, completion style)
item(tt(sort))(
If set to `true', completion functions that generate words from the
history as possible matches sort these words alphabetically instead of
keeping them in the order in which they appear in the history (from
youngest to oldest).

This is also used by the tt(_expand) completer.  Here, if it is set to
`true', the expansions generated will always be sorted.  If it is set
to `tt(menu)', then the expansions are only sorted when they are offered 
as single strings (not in the string containing all possible
expansions).
)
kindex(special-dirs, completion style)
item(tt(special-dirs))(
Normally, the completion code will not produce the directory names
`tt(.)' and `tt(..)' as possible completions.  If this style is set to
`true', it will add both `tt(.)' and `tt(..)' as possible completions;
if it is set to `tt(..)', only `tt(..)' will be added.
)
kindex(squeeze-slashes, completion style)
item(tt(squeeze-slashes))(
If set to `true', sequences of slashes (as in `tt(foo//bar)') will be
treated as if they were only one slash when completing pathnames.  This
is the usual behaviour of UNIX paths.  However, by default the file
completion function behaves as if there were a `tt(*)' between
the slashes.
)
kindex(stop, completion style)
item(tt(stop))(
If set to `true', the tt(_history_complete_word) bindable
command will stop once when reaching the beginning or end of the
history.  Invoking tt(_history_complete_word) will then wrap around to 
the opposite end of the history.  If this style is set to `false' (the 
default), tt(_history_complete_word) will loop immediately as in a
menu completion.
)
kindex(subst-globs-only, completion style)
item(tt(subst-globs-only))(
This is used by the tt(_expand) completer.  If it is set to `true',
the expansion will only be used if it resulted from globbing; hence,
if expansions resulted from the use of the tt(substitute) style
described below, but these were not further changed by globbing, the
expansions will be rejected.

The default for this style is `false'.
)
kindex(substitute, completion style)
item(tt(substitute))(
This boolean style controls whether the tt(_expand) completer will
first try to expand all substitutions in the string (such as
`tt($LPAR()...RPAR())' and `tt(${...})').

The default is `true'.
)
kindex(suffix, completion style)
item(tt(suffix))(
This is used by the tt(_expand) completer if the word starts with a
tilde or contains a parameter expansion. If it is set to `true', the word will
only be expanded if it doesn't have a suffix, i.e. if it is something
like `tt(~foo)' or `tt($foo)', but not if it is `tt(~foo/)' or
`tt($foo/bar)', unless that suffix itself contains characters eligible
for expansion.  The default for this style is `true'.
)
kindex(tag-order, completion style)
item(tt(tag-order))(
This provides a mechanism for sorting how the tags available in a
particular context will be used.

The values for the style are sets of space-separated lists of tags.
The tags in each value will be tried at the same time; if no match is
found, the next value is used.  (See the tt(file-patterns) style for
an exception to this behavior.)

For example:

example(zstyle ':completion:*:complete:-command-:*' tag-order \ 
    'commands functions')

specifies that completion in command position should offer only
completions for external commands and shell functions immediately.

In addition to tag names, each string in the value may take one of the
following forms:

startitem()
item(tt(-))(
If any string in the value consists of only a hyphen,
then em(only) the tags specified by the other strings in the value are
generated.  Normally all tags not explicitly selected are tried last
if the specified tags fail to generate any matches.  This means 
that a value consisting only of a single hyphen turns off completion.
)
item(tt(!) var(tags)...)(
A string starting with an exclamation mark
specifies names of tags that are em(not) to be used.  The effect is
the same as if all other possible tags for the context had been
listed.
)
item(var(tag)tt(:)var(label) ...)(
In strings not starting with an exclamation mark, it is also possible
to specify tag labels instead of only tags, where var(tag) is one of
the tags offered
by the completion function for the current context and var(label) is a 
name.  For this, the completion function will generate matches in the
same way as for the var(tag) but it will use the var(label) in place
of the tag in the context names used to look up styles.  If the
var(label) starts with a hyphen, the var(tag) is prepended to the
var(label) to form the name used for lookup.  This can be
used to make the completion system try a certain tag more than once,
supplying different style settings for each attempt, see below for an
example.

The var(label) may optionally be followed by a second colon and a
description.  This description will then be used for the `tt(%d)' in
the value of the tt(format) style instead of the default description
supplied by the completion function.  Spaces in the description have to 
be quoted by preceding them with a backslash and a `tt(%d)' appearing
in the description is replaced with the description given by the
completion function.
)
enditem()

In each of the cases above, the tag may also be a pattern or more than 
one pattern inside braces and separated by commas.  In this
case all of the offered tags matching the pattern(s) will be used except 
for those that are given explicitly in the same string.  There are
probably two main uses of this.  One is the case where one wants to try
one of the tags more than once, setting other styles differently for
each try, but still wants to use all the other tags without having to
repeat them all.  For example, to make completion of function names in
command position ignore all the completion functions starting with an
underscore the first time completion is tried, one could do:

example(zstyle ':completion:*:*:-command-:*' tag-order \ 
    'functions:-non-comp *' functions
zstyle ':completion:*:functions-non-comp' ignored-patterns '_*')

Here, the completion system will first try all tags offered, but will
use the tag label tt(functions-non-comp) when looking up styles for
the function names completed.  For this, the tt(ignored-patterns) style 
is set to exclude functions starting with an underscore from the set
of possible matches.  If none of the generated matches match the string 
on the line, the completion system will use the second value of the
tt(tag-order) style and complete functions names again, but this time
using the name tt(functions) to look up styles, so that the
tt(ignored-patterns) style is not used and all function names
are considered.

Of course, this can also be used to split the matches for one tag into 
different groups. For example:

example(zstyle ':completion:*' tag-order \ 
    'options:-long:long\ options
     options:-short:short\ options
     options:-single-letter:single\ letter\ options'

zstyle ':completion:*:options-long' ignored-patterns '[-+](|-|[^-]*)'
zstyle ':completion:*:options-short' ignored-patterns '--*' '[-+]?'
zstyle ':completion:*:options-single-letter' ignored-patterns '???*')

With the tt(group-names) style set, this makes options beginning with
`tt(-)tt(-)', options beginning with a single `tt(-)' or `tt(+)' but
containing multiple characters, and single-letter options be displayed
in separate groups with different descriptions.

The second interesting use of patterns is the case where one wants to
try multiple match specifications one after another.  The
tt(matcher-list) style offers something similar, but it is tested very
early in the completion system and hence can't be set for single
commands nor for more specific contexts.  Here is how to
try normal completion without any match specification and, if that
generates no matches, try again with case-insensitive matching, restricting
the effect to arguments of the command tt(foo):
example(zstyle ':completion:*:*:foo:*' tag-order '*' '*:-case'
zstyle ':completion:*-case' matcher 'm:{a-z}={A-Z}')

First, all the tags offered when completing after tt(foo) are tried using
the normal tag name.  If that generates no matches, the second value of
tt(tag-order) is used, which tries all tags again except that this time
each has tt(-case) appended to its name for lookup of styles.  Hence this
time the value for the tt(matcher) style from the second call to tt(zstyle)
in the example is used to make completion case-insensitive.

Using the tt(-e) option of the tt(zstyle) builtin command, it is
possible to specify conditions saying when certain tags are to be
used. For example:

example(zstyle -e '*:-command-:*' tag-order '
    if [[ -n $PREFIX ]]; then
      reply=( )
    else
      reply=( - )
    fi')

Makes completion in command position happen only if the string on 
the line is not empty.  This is tested using the tt(PREFIX)
parameter which is special in completion widgets; see
ifzman(zshcompwid)\
ifnzman(noderef(Completion Widgets))
for a description of these special parameters.
Setting tt(reply) to an empty array ensures that only the default
behaviour of trying all tags at once is used and setting it to an
array containing only a hyphen disables that default behaviour -- thus 
keeping all tags from being tried.

If no style has been defined for a context, the strings
`tt((|*-)argument-* (|*-)option-* values)' and `tt(options)' plus all
tags offered by the completion function will be used to provide a
sensible default behavior that causes arguments (whether normal command
arguments or arguments of options) to be completed before option names for
most commands.
)
kindex(urls, completion style)
item(tt(urls))(
This is used together with the the tt(urls) tag by completion
functions that generate URLs as possible matches.  If the value
consists of more than one string or if the only string does not name a 
file or directory, the strings are used as the URLs to complete.

If the value contains only one string and that is the name of a normal 
file, the URLs are taken from that file (where the URLs may be
separated by white space or newlines).

Finally, if the only string in the value names a directory, that
should contain sub-directories named after the
retrieval methods which occur as the first part of a URL, i.e.
`tt(http)', `tt(ftp)', `tt(bookmark)', and so on.  These
sub-directories should contain files and other sub-directories whose
pathnames are possible completions after the initial `tt(http://)',
`tt(ftp://)', etc. See the description in the file tt(_urls) in the
tt(User) sub-directory of the completion system for more information.
)
kindex(use-cache, completion style)
item(tt(use-cache))(
If this is set, the completion caching layer is activated for any completions
which use it (via the tt(_store_cache), tt(_retrieve_cache), and
tt(_cache_invalid) functions).  The directory containing the cache
files can be changed with the tt(cache-path) style.
)
kindex(use-compctl, completion style)
item(tt(use-compctl))(
If this style is set to a string em(not) equal to tt(false), tt(0),
tt(no), and tt(off), the completion system may use any completion
specifications defined with the tt(compctl) builtin command.  If the
style is unset, this is done only if the tt(zsh/compctl) module
is loaded.  The string may also contain the substring `tt(first)' to
make the definition for `tt(compctl -T)' be used, and the substring
`tt(default)' to make the one for `tt(compctl -D)' be used.

Note that this is only intended to smooth the transition from
tt(compctl) to the new completion system and may disappear in the
future.

Note also that the definitions from tt(compctl) will only be used if
there is no specific completion function for the command in question.  For
example, while completing arguments to the command tt(foo), if this was
handled by a command function tt(_foo), tt(compctl) would never be tried,
while if it was handled by tt(_default), tt(compctl) would be tried.
)
kindex(users, completion style)
item(tt(users))(
This may be set to a list of names that should be completed whenever 
a username is needed. If it is not set or the string on the line
doesn't match any of the strings in this list, all usernames will be
completed.
)
kindex(users-hosts, completion style)
item(tt(users-hosts))(
The values of this style should be of the form
`var(user)tt(@)var(host)' or `var(user)tt(:)var(host)'. It is used for
commands that need pairs of
user- and hostnames.  For such commands, only the pairs from this style 
are used and if, for example, the username is already typed, then only 
the hostnames for which there is a pair with that username is defined.

If set for the tt(my-accounts) tag, this is used for commands such as
tt(rlogin) and tt(ssh); in this case the style should contain the names of
the user's own accounts on remote hosts.  If set for the tt(other-accounts)
tag, it is used for commands such as tt(talk) and tt(finger) and should
contain other people's accounts.  Finally, it may also be used by some
commands with the tt(accounts) tag.
)
kindex(users-hosts-ports, completion style)
item(tt(users-hosts-ports))(
Like tt(users-hosts) but used for commands like tt(telnet) and
containing strings of the form `var(user)tt(@)var(host)tt(:)var(port)'.
)
kindex(verbose, completion style)
item(tt(verbose))(
This is used in several contexts to decide if only a simple or a
verbose list of matches should be generated. For example some commands 
show descriptions for option names if this style is `true'.

The default value for this style is `true'.
)
kindex(word, completion style)
item(tt(word))(
This is used by the tt(_list) completer, which prevents the insertion of
completions until a second completion attempt when the line has not
changed.  The normal way of finding out if the line has changed is to
compare its entire contents between the two occasions.  If this style is
true, the comparison is instead performed only on the current word.
Hence if completion is performed on another word with the same contents,
completion will not be delayed.
)
enditem()

texinode(Control Functions)(Bindable Commands)(Completion System Configuration)(Completion System)
sect(Control Functions)
cindex(completion system, choosing completers)

The initialization script tt(compinit) redefines all the widgets
which perform completion to call the supplied widget function
tt(_main_complete).  This function acts as a wrapper calling the
so-called `completer' functions that generate matches.  If
tt(_main_complete) is called with arguments, these are taken as the
names of completer functions to be called in the order given.  If no
arguments are given, the set of functions to try is taken from the
tt(completer) style.  For example, to use normal completion and
correction if that doesn't generate any matches:

example(zstyle ':completion:*' completer _complete _correct)

after calling tt(compinit). The default value for this style is
`tt(_complete _ignored)', i.e. normally only ordinary completion is tried,
first with the effect of the tt(ignored-patterns) style and then without
it.  The tt(_main_complete) function uses the return value of the completer
functions to decide if other completers should be called.  If the return
value is zero, no other completers are tried and the tt(_main_complete)
function returns.

If the first argument to tt(_main_complete) is a single hyphen, the
arguments will not be taken as names of completers. Instead, the
second argument gives a name to use in the var(completer) field of the 
context and the other arguments give a command name and arguments to
call to generate the matches.

The following completer functions are contained in the distribution (users
may write their own):

cindex(completion system, completers)
startitem()
findex(_all_matches)
item(tt(_all_matches))(
This completer can be used to add a string consisting of all other
matches.  To ensure, that this string is always added, this completer
has to be used as the first completer in the list.  The
tt(avoid-completer) style is used to decide if the string should be
added.  This will only be done if the matches were generated by a
completer not named by one of the values of the style.

This function also uses the style tt(old-matches).  If it is set to
`true' or to the string `tt(only)' and there is a list of matches from 
a previous completion, those matches will be inserted in the command
line.  If it is set to the the string `tt(only)', it will only insert
an old list and won't add the string for all matches of the list
currently being generated.

With the tt(old-matches) style set, this completer should probably not 
be called unconditionally.  Instead one could use the tt(-e) option of 
the tt(zstyle) builtin command to add a condition to the tt(completer) 
or to the tt(old-matches) style.  Alternatively, one could use the
tt(_generic) function to bind tt(_all_matches) to a separate key
binding, for example:

example(zle -C all-matches complete-word _generic
bindkey '^Xa' all-matches
zstyle ':completion:all-matches:*' old-matches only
zstyle ':completion:all-matches:*' completer _all_matches)
)
findex(_approximate)
item(tt(_approximate))(
This completer function uses the tt(_complete) completer to generate
a list of strings for the context the cursor is currently in, allowing 
you to specify a maximum number of errors:  see the description of
approximate matching in
ifzman(\
zmanref(zshexpn)
)\
ifnzman(\
noderef(Filename Generation)
)\
for how errors are counted.  The resulting list of corrected and completed
strings is then presented to the user.  The intended use of this completer
function is to try after the normal tt(_complete) completer by setting:

example(zstyle ':completion:*' completer _complete _approximate)

This will give correcting completion if and only if
normal completion yields no possible completions.  When
corrected completions are found, the completer will normally start
menu completion allowing you to cycle through these strings.

This completer uses the tags tt(corrections) and tt(original) when
generating the possible corrections and the original string.  The
tt(format) style for the former may contain the additional sequences
`tt(%e)' and `tt(%o)' which will be replaced by the number of errors
accepted to generate the corrections and the original string,
respectively.

As with all completers, tt(_approximate) uses its name without the
underscore in the var(completer) field of the context name.  Once it
has started trying to generate matches, it will append a minus sign
and the number of errors accepted to its name.  tt(_approximate) will
first look for completions with one error, then two, and on so up to the
limit on the number of errors set by the tt(max-errors) style.
Hence on the first try the completer field of the context contains
`tt(approximate-1)', on the second try `tt(approximate-2)', and so on.

When tt(_approximate) is called from another function, the number of
errors to accept may be given with the tt(-a) option.  Its argument
should be the same as the value of the tt(max-errors) style, all in one
string.

Note that this completer (and the tt(_correct) completer mentioned
below) can be quite expensive to call, especially when a large number
of errors are allowed.  One way to avoid this is to set up the
tt(completer) style using the tt(-e) option to zstyle so that some
completers are only used when completion is attempted a second time on 
the same string, e.g.:

example(zstyle ':completion:*' completer '
  if [[ $_last_try != "$HISTNO$BUFFER$CURSOR" ]]; then
    _last_try="$HISTNO$BUFFER$CURSOR"
    reply=(_complete _match _prefix)
  else
    reply=(_ignored _correct _approximate)
  fi')

This uses the tt(HISTNO) parameter and the tt(BUFFER) and tt(CURSOR)
special parameters that are available inside zle and completion
widgets to find out if the command line hasn't changed since the last
time completion was tried.  Only then are the tt(_ignored),
tt(_correct) and tt(_approximate) completers called.
)
findex(_complete)
item(tt(_complete))(
This completer generates all possible completions in a context-sensitive
manner, i.e. using the settings defined with the tt(compdef) function
explained above and the current settings of all special parameters.
This gives the normal completion behaviour.

To complete arguments of commands, tt(_complete) uses the utility function
tt(_normal), which is in turn responsible for finding the particular
function; it is described below.  Various contexts of the form
tt(-)var(context)tt(-), as mentioned above for the tt(#compdef) tag, are
handled specially.  These are:

startitem()
kindex(-array-value-, completion context)
item(tt(-array-value-))(
for completion on the right hand side of an array-assignment
(`tt(foo=LPAR()...RPAR())').
)
kindex(-brace-parameter-, completion context)
item(tt(-brace-parameter-))(
for completing the name of a parameter expansion within braces
(`tt(${...})').
)
kindex(-command-, completion context)
item(tt(-command-))(
for completing in a command position.
)
kindex(-condition-, completion context)
item(tt(-condition-))(
for completion inside conditions (`tt([[...]])').
)
kindex(-default-, completion context)
item(tt(-default-))(
for generating completions when no special completion function is used.
)
kindex(-equal-, completion context)
item(tt(-equal-))(
for completion of words beginning with an equals sign
)
kindex(-first-, completion context)
item(tt(-first-))(
for adding completions before any other completion functions are
tried; if this
function sets the tt(_compskip) parameter to tt(all), no other
completion functions will be called, if it is set to a string
containing the substring tt(patterns), no pattern completion functions
will be called, and if it is set to a string containing tt(default)
the function for the `tt(-default-)' context will not be called, but
functions defined for commands will.
)
kindex(-math-, completion context)
item(tt(-math-))(
for completion inside mathematical contexts, such as
`tt(LPAR()LPAR())...tt(RPAR()RPAR())'.
)
kindex(-parameter-, completion context)
item(tt(-parameter-))(
for completing the name of a parameter expansion (`tt($...)').
)
kindex(-redirect-, completion context)
item(tt(-redirect-))(
for completion after a redirection operator.
)
kindex(-subscript-, completion context)
item(tt(-subscript-))(
for completion inside subscripts.
)
kindex(-tilde-, completion context)
item(tt(-tilde-))(
for completion after a tilde (`tt(~)') character, but before a slash.
)
kindex(-value-, completion context)
item(tt(-value-))(
for completion on the right hand side of an assignment.
)
enditem()

Default implementations are supplied for each of these
contexts, in most cases named after the context itself
(e.g. completion for the `tt(-tilde-)' context is done by the function 
named `tt(_tilde)').

Before trying to find a function for a specific context, tt(_complete) 
checks if the parameter `tt(compcontext)' is set.  If it is set to an
array, the elements are taken to be the possible matches which will be
completed using the tag `tt(values)' and the description
`tt(value)'.   If it is set to an associative array, the keys are used
as the possible completions and the values (if non-empty) are used as
descriptions for the matches.  If `tt(compcontext)' is set to a string
containing colons, it should be of
the form `var(tag)tt(:)var(descr)tt(:)var(action)'.  In this case the
var(tag) and var(descr) give the tag and description to use and the
var(action) says what should be completed in one of the forms
described for the tt(_arguments) utility function below.

Finally, if `tt(compcontext)' is set to a string without colons, the
value is taken as the name of the context to use and the function
defined for that context will be called.  For this purpose, there is a
special context named tt(-command-line-) that completes whole command
lines (commands and their arguments) and is not used by the completion
system itself, but has a function handling completion for it.
)
findex(_correct)
item(tt(_correct))(
Generate corrections, but not completions, for the current word; this is
similar to tt(_approximate) but will not allow any number of extra
characters at the cursor as that completer does, hence this is
similar to spell-checking.  It calls tt(_approximate) but uses a
different var(completer) field in the context name.

For example, with:

example(zstyle ':completion:::::' completer _complete _correct _approximate
zstyle ':completion:*:correct:::' max-errors 2 not-numeric
zstyle ':completion:*:approximate:::' max-errors 3 numeric)

correction will accept up to two errors.  If a numeric argument is
given, correction will not be performed, but correcting completion
will be, and will accept as many errors as given by the numeric
argument.  Without a numeric argument, first correction and then
correcting completion will be tried, with the first one accepting two
errors and the second one accepting three errors.

When tt(_correct) is called as a function, the number of errors to accept
may be given following the tt(-a) option.  The argument should be the same
as the value of the tt(accept) style, all in one string.

This completer function is intended to be used without the
tt(_approximate) completer or, as in the example, just before
it.  Using it after the tt(_approximate) completer is useless since
tt(_approximate) will at least generate the corrected strings
generated by the tt(_correct) completer -- and probably more.
)
findex(_expand)
item(tt(_expand))(
This completer function does not really do completion, but instead
checks if the word on the command line is eligible for expansion and,
if it is, gives detailed control over how this expansion is done.  When
using this, one should not use the tt(expand-or-complete) widget, but
instead use tt(complete-word), as tt(expand-or-complete)
will expand the string on the line before the completion widget is
called.  Also, this completer should be called before the tt(_complete) 
completer function.

The tags used when generating expansions are tt(all-expansions) for
the string containing all possible expansions, tt(expansions) when
adding the possible expansions as single matches and tt(original) when 
adding the original string from the line.  In which order these strings 
are generated and which of these strings are generated at all can be
controlled by using the tt(group-order) style and by modifying the
tt(tag-order) style, as usual.

The format string for tt(all-expansions) and for tt(expansions) may
contain the sequence `tt(%o)' which will be replaced by the original
string from the line.

Which kind of expansion is tried is controlled by the tt(substitute),
tt(glob) and tt(subst-globs-only) styles.

When tt(_expand) is called as a function, the different modes may be
selected with options.  The tt(-s) to tt(substitute), tt(-g) to
tt(glob) and tt(-o) to tt(subst-globs-only).
)
findex(_expand_alias)
item(tt(_expand_alias))(
If the word the cursor is on is an alias, it is expanded and no other
completers are called.  The types of aliases which are to be expanded can
be controlled with the tt(regular), tt(global) and tt(disabled)
styles.

This function is also a bindable command, see
ifzman(the section `Bindable Commands' below)\
ifnzman(noderef(Bindable Commands)).
)
findex(_history)
item(tt(_history))(
Complete words from the shell's command  history.  This completer 
uses the tt(remove-all-dups), and tt(sort) styles also used by the
tt(_history_complete_word) bindable command, see
ifzman(the section `Bindable Commands' below)\
ifnzman(noderef(Bindable Commands))
and
ifzman(the section `Completion System Configuration' above)\
ifnzman(noderef(Completion System Configuration)).
)
findex(_ignored)
item(tt(_ignored))(
The tt(ignored-patterns) style can be set to a list of patterns which are
compared against possible completions; matching ones are removed.
With this completer those matches can be reinstated, as
if no tt(ignored-patterns) style were set.  The completer actually
generates its own list of matches; which completers are used
for this is determined in the same way as for the tt(_prefix)
completer.

The tt(single-ignored) style is used if only one
match could be generated.  It can be set to tt(show) to prevent that match 
from being displayed or inserted into the line, or it can be set to
tt(menu), in which case the single match and the original string from the
line will be offered in a menu completion.
)
findex(_list)
item(tt(_list))(
This completer allows one to delay the insertion of matches until
completion is attempted a second time without the word on the line
being changed.  On the first attempt, only the list of matches will be
shown.  It is affected by the styles tt(condition) and tt(word), see
ifzman(the section `Completion System Configuration' above)\
ifnzman(noderef(Completion System Configuration)).
)
findex(_match)
item(tt(_match))(
This completer is intended to be used after the tt(_complete)
completer. It allows one to give patterns on the command line and
to complete all strings matching these patterns from the set of
possible completions for the context the cursor is in, without having
to set the tt(GLOB_COMPLETE) option.

Normally this will be done by taking the pattern from the line,
inserting a `tt(*)' at the cursor position and comparing the resulting
pattern with the possible completions generated.  However, if the
tt(match-original) style has a value of tt(only), no `tt(*)' will be
inserted.  If tt(match-original) has any other non-empty string as its
value, this completer will first try to generate matches without, then
with a `tt(*)' inserted at the cursor position.

The generated matches will be offered in a menu completion unless the
tt(insert-unambiguous) style is set to `true'.  In
this case menu completion will only be started if no unambiguous string
could be generated that is at least as long as the original string.
The style may also be set to the string `tt(pattern)'.  This will keep 
the pattern on the line intact as long as there isn't an unambiguous
completion with which it could be replaced.

Note that the matcher specifications defined globally or used by the
completion functions will not be used.
)
findex(_menu)
item(tt(_menu))(
This completer is a simple example function implemented to show how
menu completion can be done in shell code.  It should be used as the
first completer and has the effect of making the code perform
menu completion.  Note that this is independent of the setting of the
tt(MENU_COMPLETE) option and does not work with the other
menu completion widgets such as tt(reverse-menu-complete), or
tt(accept-and-menu-complete).
)
findex(_oldlist)
item(tt(_oldlist))(
This completer controls how the standard completion widgets behave
when there is an existing list of completions which may have been
generated by a special completion (i.e. a separately-bound completion
command).  It allows the ordinary completion keys to continue to use the
list of completions thus generated, instead of producing a new list of
ordinary contextual completions.
It should appear in the list of completers before any of
the widgets which generate matches.  It uses two styles: tt(old-list) and
tt(old-menu), see
ifzman(the section `Completion System Configuration' above)\
ifnzman(noderef(Completion System Configuration)).
)
findex(_prefix)
item(tt(_prefix))(
This completer can be used to try completion with the suffix (everything
after the cursor) ignored.  In other words, the suffix will not be
considered to be
part of the word to complete and hence does not need to be matched.  It
uses the tt(completer) style to decide which other completers to call to
try to generate matches.  If this style is unset, the list of completers
set for the current context is used -- except, of course,
the tt(_prefix) completer itself.  Furthermore, if this completer appears
more than once in the list of completers only those completers not
already tried by the last invocation of tt(_prefix) will be
called.

For example, consider this global tt(completer) style:

example(zstyle ':completion:*' completer \ 
    _complete _prefix _correct _prefix:foo)

Here, the tt(_prefix) completer tries normal completion but ignoring the
suffix.  If that doesn't generate any matches, and neither does
the call to the tt(_correct) completer after it, tt(_prefix) will 
be called a second time and, now only trying correction with the
suffix ignored.  If you want to use tt(_prefix) as the last resort and
try only normal completion, you can use:

example(zstyle ':completion:*' completer _complete ... _prefix
zstyle ':completion::prefix:*' completer _complete)

The tt(add-space) style is also used.  If it is set to `true' then
tt(_prefix) will insert a space between the matches generated (if any) 
and the suffix.

Note that this completer is only useful if the
tt(COMPLETE_IN_WORD) option is set; otherwise, the cursor will
be moved to the end of the current word before the completion code is
called and hence there will be no suffix.
)
enditem()

texinode(Bindable Commands)(Completion Functions)(Control Functions)(Completion System)
sect(Bindable Commands)
cindex(completion system, bindable commands)

In addition to the context-dependent completions provided, which are
expected to work in an intuitively obvious way, there are a few widgets
implementing special behaviour which can be bound separately to keys.  The
following is a list of these and their default bindings.

startitem()
findex(_bash_completions)
item(tt(_bash_completions))(
This function is used by two widgets, tt(_bash_complete-word) and
tt(_bash_list-choices).  It exists to provide compatibility with
completion bindings in bash.  The last character of the binding determines
what is completed: `tt(!)', command names; `tt($)', environment variables;
`tt(@)', host names; `tt(/)', file names; `tt(~)' user names.  In bash, the
binding preceded by `tt(\e)' gives completion, and preceded by `tt(^X)'
lists options.  As some of these bindings clash with standard zsh
bindings, only `tt(\e~)' and `tt(^X~)' are bound by default.  To add the
rest, the following should be added to tt(.zshrc) after tt(compinit) has
been run:

example(for key in '!' '$' '@' '/' '~'; do
  bindkey "\e$key" _bash_complete-word
  bindkey "^X$key" _bash_list-choices
done)

This includes the bindings for `tt(~)' in case they were already bound to
something else; the completion code does not override user bindings.
)
findex(_correct_filename (^XC))
item(tt(_correct_filename (^XC)))(
Correct the filename path at the cursor position.  Allows up to six errors
in the name.  Can also be called with an argument to correct
a filename path, independently of zle; the correction is printed on
standard output.
)
findex(_correct_word) (^Xc)
item(tt(_correct_word) (^Xc))(
Performs correction of the current argument using the usual contextual
completions as possible choices. This stores the string
`tt(correct-word)' in the var(function) field of the context name and
then calls the tt(_correct) completer.
)
findex(_expand_alias (^Xa))
item(tt(_expand_alias (^Xa)))(
This function can be used as a completer and as a bindable command.
It expands the word the cursor is on if it is an alias.  The types of
aliases expanded can be controlled with the tt(regular), tt(global) and
tt(disabled) styles.

When used as a bindable command there is one additional feature that
can be selected by setting the tt(complete) style to `true'.  In this
case, if the word isn't the name of an alias, tt(_expand_alias) tries
to complete the word to a full alias name without expanding it (but
leaving the cursor directly after the completed word so that invoking
tt(_expand_alias) once more will expand the now-complete alias name).
)
findex(_expand_word (^Xe))
item(tt(_expand_word (^Xe)))(
Performs expansion on the current word:  equivalent to the standard
tt(expand-word) command, but using the tt(_expand) completer.  Before
calling it, the var(function) field is set to `tt(expand-word)'.
)
findex(_generic)
item(tt(_generic))(
This function is not defined as a widget and not bound by
default. However, it can be used to define a widget and will then
store the name of the widget in the var(function) field of the context 
and call the completion system. This allows custom completion widgets
with their own set of style settings to be easily defined. For example, 
to define a widget that does normal completion and starts
menu selection, one could do:

example(zle -C foo complete-word _generic
bindkey '...' foo
zstyle ':completion:foo:*' menu yes select=1)
)
findex(_history_complete_word) (\e/))
item(tt(_history_complete_word) (\e/))(
Complete words from the shell's command history. This uses the
tt(list), tt(remove-all-dups), tt(sort), and tt(stop) styles.
)
findex(_most_recent_file (^Xm))
item(tt(_most_recent_file (^Xm)))(
Complete the name of the most recently modified file matching the pattern
on the command line (which may be blank).  If given a numeric argument
var(N), complete the var(N)th most recently modified file.  Note the
completion, if any, is always unique.
)
findex(_next_tags (^Xn))
item(tt(_next_tags) (^Xn))(
This command alters the set of matches used to that for the next tag, or
set of tags, either as given by the tt(tag-order) style or as set by
default; these matches would otherwise not be available.
Successive invocations of the command cycle through all possible sets of
tags.
)
findex(_read_comp (^X^R))
item(tt(_read_comp (^X^R)))(
Prompt the user for a string, and use that to perform completion on the
current word.  There are two possibilities for the string.  First, it can
be a set of words beginning `tt(_)', for example `tt(_files -/)', in which
case the function with any arguments will be called to generate the
completions.  Unambiguous parts of the function name will be completed
automatically (normal completion is not available at this point) until a
space is typed.

Second, any other string will be passed as a set of arguments to
tt(compadd) and should hence be an expression specifying what should
be completed.

A very restricted set of editing commands is available when reading the
string:  `tt(DEL)' and `tt(^H)' delete the last character; `tt(^U)' deletes
the line, and `tt(^C)' and `tt(^G)' abort the function, while `tt(RET)'
accepts the completion.  Note the string is used verbatim as a command
line, so arguments must be quoted in accordance with standard shell rules.

Once a string has been read, the next call to tt(_read_comp) will use the
existing string instead of reading a new one.  To force a new string to be
read, call tt(_read_comp) with a numeric argument.
)
findex(_complete_debug (^X?))
item(tt(_complete_debug (^X?)))(
This widget performs ordinary completion, but captures in a temporary file
a trace of the shell commands executed by the completion system.  Each
completion attempt gets its own file.  A command to view each of these
files is pushed onto the editor buffer stack.
)
findex(_complete_help (^Xh))
item(tt(_complete_help (^Xh)))(
This widget displays information about the context names, 
the tags, and the completion functions used 
when completing at the current cursor position. If given a numeric
argument other than tt(1) (as in `tt(ESC-2 ^Xh)'), then the styles
used and the contexts for which they are used will be shown, too.

Note that the information about styles may be incomplete; it depends on the
information available from the completion functions called, which in turn
is determined by the user's own styles and other settings.
)
findex(_complete_tag (^Xt))
item(tt(_complete_tag (^Xt)))(
This widget completes symbol tags created by the tt(etags) or tt(ctags)
programmes (note there is no connection with the completion system's tags)
stored in a file tt(TAGS), in the format used by tt(etags), or tt(tags), in the
format created by tt(ctags).  It will look back up the path hierarchy for
the first occurrence of either file; if both exist, the file tt(TAGS) is
preferred.  You can specify the full path to a tt(TAGS) or tt(tags) file by
setting the parameter tt($TAGSFILE) or tt($tagsfile) respectively.
The corresponding completion tags used are tt(etags) and tt(vtags), after
emacs and vi respectively.
)
enditem()

texinode(Completion Functions)(Completion Directories)(Bindable Commands)(Completion System)
sect(Utility Functions)
cindex(completion system, utility functions)

Descriptions follow for utility functions that may be
useful when writing completion functions.  Most of these reside in the
tt(Base) subdirectory. Like the example 
functions for commands in the distribution, the utility functions
generating matches all follow the convention of returning zero if they
generated completions and non-zero if no matching completions could be 
added.

When writing completion functions or other ZLE widgets that call
completion, it might be interesting to know about two more features
offered by the tt(_main_complete) function. The arrays
tt(compprefuncs) and tt(comppostfuncs) may be set to contain names of
functions that are to be called immediately before or after completion 
has been tried. The functions will only be called once, unless they
put themselves into the arrays again.

startitem()
findex(_all_labels)
item(tt(_all_labels) [ tt(-12VJ) ] var(tag) var(name) var(descr) [ var(command) var(args) ... ])(
This is a convenient interface to the tt(_next_label) function below,
implementing the loop shown in the tt(_next_label) example.  The
var(command) is the one that should be called to generate the matches. The
options stored in the parameter var(name) will automatically be inserted
into the var(args) given to the var(command).  Normally, they are put
directly after the var(command), but if one of the var(args) is a single
hyphen, they are inserted directly before that. If the hyphen is the last
argument, that will be removed from the argument list before the
var(command) is called. This allows tt(_all_labels) to be used in almost all
cases where the matches can be generated by a single call to the
tt(compadd) builtin command or by a call to one of the utility functions.

For example:

example(local expl
...
if _requested foo; then
  ...
  _all_labels foo expl '...' compadd ... - $matches
fi)

Will complete the strings from the tt(matches) parameter, using
tt(compadd) with additional options which will take precedence over
those generated by tt(_all_labels).
)
findex(_alternative)
item(tt(_alternative) [ tt(-C) var(name) ] var(specs) ...)(
This function is useful in simple cases where multiple tags are available.
Essentially, it implements a loop like the one described for the tt(_tags)
function above.

The tags to use and the action to perform if a tag is requested are
described using the var(specs) which are of the form:
`var(tag)tt(:)var(descr)tt(:)var(action)'. The var(tag)s are offered using
tt(_tags) and if the tag is requested, the var(action) is executed with the
given description var(descr).  The var(action)s supported are those used
by the tt(_arguments) function (described below), without the
`tt(->)var(state)' and `tt(=)var(...)' forms.

For example, the var(action) may be a simple function call. With that
one could do:

example(_alternative \ 
    'users:user:_users' \ 
    'hosts:host:_hosts')

to offer usernames and hostnames as possible matches (which are
generated by the tt(_users) and tt(_hosts) functions respectively).

Note that, like tt(_arguments) this will also use tt(_all_labels) to execute 
the actions, so one doesn't need to call that explicitly unless
another tag is to be used, for example in a function called from
tt(_alternative).

Like tt(_tags) this function supports the tt(-C) option to give a
different name for the argument context field.
)
findex(_arguments)
item(tt(_arguments) var(spec) ...)(
This function can be used to complete words on the line by describing the
options and arguments which may be passed to the command for which
completion is being performed.  The description is given as arguments to
this function, with each var(spec) describing one option or normal
argument of the command.  The forms of var(spec) understood are:

startitem()
xitem(var(n)tt(:)var(message)tt(:)var(action))
item(var(n)tt(::)var(message)tt(:)var(action))(
This describes the var(n)'th normal argument.  The var(message) will be 
printed above the matches generated and the var(action) says what can
be completed in this position (see below).  If there are two colons
before the var(message), this describes an optional argument.  If the
var(message) contains only white space, nothing will be printed above
the matches unless the action adds an explanation string itself.
)
xitem(tt(:)var(message)tt(:)var(action))
item(tt(::)var(message)tt(:)var(action))(
Like the previous one, but describing the em(next) argument. I.e. if
you want to describe all arguments a command can get, you can leave
out the numbers in the description and just use this form to describe
them one after another in the order they have to appear on the line.
)
xitem(tt(*:)var(message)tt(:)var(action))
xitem(tt(*::)var(message)tt(:)var(action))
item(tt(*:::)var(message)tt(:)var(action))(
This describes how arguments (usually non-option arguments, those not
beginning with tt(-) or tt(+)) are to be completed when no description
with one of the first two forms was given. This also means that any number
of arguments can be completed.

With two colons before the var(message), the tt(words) special array and
the tt(CURRENT) special parameter are modified to refer only to the
normal arguments when the var(action) is executed or evaluated.  With
three colons before the var(message) they are modified to refer only to
the normal arguments covered by this description.
)
item(var(optspec)[var(description) ...])(
This describes an option and (if var(description) is given) the arguments
that have to come after the option.  If no var(description) is given, this
means to offer only the option name as a possible completion in the right
places.  (Note that the brackets, above, around var(description), indicate
that zero or more var(description)s may appear; but the brackets are not
themselves part of this format.  If brackets are used, they are part of
the var(optspec); see below.)

In the descriptions below, the option names represented by var(optname)
are normally taken to be multi-character names, and a word from the line
is considered to contain only one option (or none).  By giving the tt(-s)
option to tt(_arguments) before the first var(spec), each var(optname) is
considered to be a single character and each word from the line may
contain more than one such option letter.  However, words beginning with
two hyphens (like `tt(-)tt(-prefix)') are still considered to contain only
one option name.  This allows the use of the `tt(-s)' option to describe
single-letter options together with such long option names.

The tt(-s) option may be combined with the option tt(-w) to say that more
option characters are to be expected even after an option that takes an
argument.  For example, if a command takes the options `tt(a)' and `tt(b)',
where `tt(a)' takes an argument in the next word, tt(_arguments) would
normally not complete the other option directly after `tt(-a)', but it would
allow that if given the tt(-w) option.

Similarly, the option tt(-W) may be given together with tt(-s) to force
completion of single-letter options even after options that get an
argument in the same word.  For example, if a command takes the options
`tt(a)' and `tt(b)', where `tt(a)' needs an argument in the same word,
directly after the option character, tt(_arguments) would normally only
execute the action for that argument and not offer other single-letter
options as possible completions.  If given the tt(-W) option, it will
offer other options as possible completions after executing the action
for the argument.  Note that, depending on the action, this may mean
that the other options can't really be completed, but at least they will
be listed.  For more control, use an utility function like tt(_guard) in
the argument's action.

The forms of var(optspec) are:

startitem()
item(tt(*)var(optspec))(
If the option may be given more than once, a star (`tt(*)') must be
added in front of one of the following forms of var(optspec).  Otherwise,
if the option is already on the line and to the left of the cursor, it
is not offered as a possible completion again.
)
xitem(tt(-)var(optname))
item(tt(+)var(optname))(
In the simplest form the var(optspec) is just the option name beginning
with a minus or a plus sign, such as `tt(-foo)'.  The first argument for
the option (if any) must follow as a em(separate) word directly after the
option.

If the command accepts the option with either a leading minus or a leading
plus sign, use either `tt(-+)var(optname)' or `tt(+-)var(optname)' to
define both variants at once.

In all the following forms, the leading `tt(-)' may be replaced or paired
with `tt(+)' in this way.
)
item(tt(-)var(optname)tt(-))(
The first argument of the option must come directly after the option name
em(in the same word), as in `tt(-foo-:)var(...)'.
)
item(tt(-)var(optname)tt(+))(
The first argument may appear immediately after var(optname) in the same
word, or may instead appear as a separate word after the option.
)
item(tt(-)var(optname)tt(=))(
The argument may appear as the next word, or in same word as the option
name provided that it is separated from it by an equals sign.
)
item(tt(-)var(optname)tt(=-))(
The argument to the option must appear after an equals sign in the same
word, and may not be given in the next argument.
)
item(var(optspec)tt([)var(explanation)tt(]))(
An explanation string may be appended to any of the preceding forms of
var(optspec) by enclosing it in brackets, as in `tt(-q[query operation])'.

The tt(verbose) style is used to decide if these explanation strings
should be displayed with the option in a completion listing.

If no bracketed explanation string is given but the tt(auto-description)
style is set and only one argument is described for this var(optspec), the
value of the style is displayed, with any appearance of the sequence
`tt(%d)' in it replaced by the var(message) of the first var(description)
that follows the var(optspec); see below.
)
enditem()

Note that the special meaning of a leading or trailing tt(-) or tt(+) in
var(optspec) means that when the command to be completed accepts options
like `tt(-+)' or `tt(-=)', the second character has to be quoted with a
backslash, as in `tt(-\+)'.

Each var(description) following an var(optspec) must take one of the
following forms:

startitem()
xitem(tt(:)var(message)tt(:)var(action))
item(tt(::)var(message)tt(:)var(action))(
Describes a mandatory argument with one colon, or an optional argument
with two colons.  As in other forms of var(spec), the var(message) will be
printed above the matches generated (unless it contains only white
space, see above) and the var(action) says what can be
completed in this position.
)
xitem(tt(:*)var(pattern)tt(:)var(message)tt(:)var(action))
xitem(tt(:*)var(pattern)tt(::)var(message)tt(:)var(action))
item(tt(:*)var(pattern)tt(:::)var(message)tt(:)var(action))(
This describes multiple arguments.  Only the em(last) description may be
given in this form.  If the var(pattern) is empty (i.e., tt(:*:)), all
following words on the line are to be completed as described by the
var(action); otherwise, all words up to a word matching the var(pattern)
are to be completed using the var(action).

When the var(message) is preceded by two colons, the tt(words) special
array and the tt(CURRENT) special parameter are modified during the
execution or evaluation of the var(action) to refer only to the words
after the option.  When preceded by three colons, they are modified to
refer only to the words covered by this description.

Note that only one such `tt(:*)'-specification is useful
and no other argument specification may be given after it.
)
enditem()
)
enditem()

To include a colon in any var(optname), var(message), or var(action)
anywhere above, it has to be preceded by a backslash, as `tt(\:)'.

Each of the six forms of var(spec) (yes, there are six, keep track of
the nestings) may be preceded by a list
of option names and argument numbers with which the option or argument
described is mutually exclusive.  This list is given in parentheses, as
in `tt((-two -three 1)-one:...)' or `tt((-foo):...)'.  In the first
example, the options `tt(-two)' and `tt(-three)' and the first
argument will not be offered as possible completions if the option
`tt(-one)' is on the line before the cursor, and in the second example
the option `tt(-foo)' will not be offered if the argument described by
the specification is on the line.

The list may also contain a single star (tt(*)) as one of its elements to
specify that the description for the rest arguments (i.e. a specification
of the form `tt(*:...)') should not be used, a colon (tt(:)) to specify
that the descriptions for all normal (non-option-) arguments should not be
used and a hyphen (tt(-)) to specify that the descriptions for all options
should not be used.  This paragraph desperately needs rewriting.

To simplify writing writing functions that call tt(_arguments) more
than once, the var(specs) may also start with the character `tt(!)'
(exclamation mark) to make the spec em(not) be completed.  However, if
this is used with one of the forms describing options, the option (and 
its arguments, if it takes any) will be understood and skipped if they 
appear on the command line.  It's just that the option itself will not
be completed. This is intended to be used with an array containing the 
options used in the first call to tt(arguments).  The second call can
then use `tt(\!${^global_options})' to ignore those options and
complete only the ones understood in the current context.

In every case above, the var(action) determines how the possible
completions should be generated.  In places where no sensible matches can
be generated, the action should consist of only a space. This will make
the var(message) be displayed but no possible completions listed. Note
that even in this case the colon at the end of the var(message) is
needed. The only case where it can be left is when neither a var(message),
nor a var(action) is given.

Except for the `tt(->)var(string)' form below, the var(action) will be
executed by calling the tt(_all_labels) function to process all tag labels,
so one doesn't need to call that explicitly unless another tag is to
be used, for example in a function called in the var(action).

When only one of a fixed set of strings can be completed, the var(action)
can consist of these strings as a list in parentheses, as in:

example(tt(:foo:LPAR()foo bar baz)tt(RPAR()))

Such a list in doubled parentheses should contain strings consisting of
the string to complete followed by `tt(\:)' and a description, as in:

example(tt(:foo:LPAR()LPAR()a\:bar b\:baz)tt(RPAR()RPAR()))

The matches will be listed together with their descriptions if the
tt(description) style for the tt(values) tag is set.

vindex(context, use of)
vindex(line, use of)
vindex(opt_args, use of)
An var(action) of the form `tt(->)var(string)' is used by functions
that implement a state machine. In this case, the `var(string)'s (with
all leading and trailing spaces and tabs removed) of all actions that
have to be used will be stored in the global array tt(state).  The
function returns with a non-zero return value if the cursor is not in
a position where options can be completed or if the current word could 
not be completed to an option.  But if the tt(-R) option is given to
tt(_arguments), the function will instead return with a return
value of 300 (to make it distinguishable from other return values)
after setting the global `tt(context)', `tt(line)' and `tt(opt_args)'
parameters as described below, and without resetting any changes made
to the special parameters such as tt(PREFIX) and tt(words).  This
enables wrapper functions around tt(_arguments) to be able to find out
if they have to make sure that the special completion parameters are
not reset when they return.

Note that this means that a function calling tt(_arguments) with at least
one action containing such a `tt(->)var(string)' has to declare
appropriate local parameters as in:

example(local context state line
typeset -A opt_args)

This will ensure that tt(_arguments) does not create unused global
parameters.

vindex(expl, use of)
A string in braces is evaluated to generate the matches and if the
var(action) does not begin with an opening parentheses or brace, it
is also split into separate words and executed. If the var(action)
starts with a space, this list of words will be invoked unchanged,
otherwise it will be invoked with some extra strings placed after the
first word which can be given as arguments to the tt(compadd) builtin
command and which make sure that the var(message) given
in the description will be shown above the matches. These arguments
are taken from the array parameter `tt(expl)' which will be set up
before executing the var(action) and hence may be used in it (normally 
in an expansion like `tt($expl[@])').

If the var(action) starts with `tt(= )' (an equals sign followed by a
space), tt(_arguments) will insert the contents of the var(argument)
field of the current context as the new first element in the tt(words) 
special array and increments the value of the tt(CURRENT) special
parameter. In other words, it inserts a dummy element in the tt(words) 
array and makes tt(CURRENT) still point to the word in that array
where the cursor is. This is only really useful when used with one of
the forms that make tt(_arguments) modify the tt(words) array to
contain only some of the words from the line, i.e. one of the argument 
description forms where the var(message) is preceded by two or three
colons. For example, when the function called in the action for such
an argument itself uses tt(_arguments), the dummy element is needed to 
make that second call to tt(_arguments) use all words from the
restricted range for argument parsing. Without the inserted dummy
element, the first word in the range would be taken (by the second
tt(_arguments)) to be the command name and hence ignored.

During the evaluation or execution of the action the array `tt(line)'
will be set to the command name and normal arguments from the command
line, i.e. to the words from the command line excluding all options
and their arguments. These are stored in the associative array
`tt(opt_args)', using the option names as keys and their arguments as
the values. For options that have more than one argument these are
given as one string, separated by colons. All colons in the original
arguments are preceded with backslashes.

The parameter `tt(context)' (set only in the calling function when
using an action of the form `tt(->)var(string)', not during the
evaluation of other var(action)s) is set to the automatically
created context names. These are either strings of the form
`tt(option)var(-opt)tt(-)var(n)' for the var(n)'th argument of the
option var(-opt), or strings of the form `tt(argument-)var(n)' for
the var(n)'th argument (for rest arguments the var(n) is the string
`tt(rest)'). For example, when completing the argument of the tt(-o)
option, the name is `tt(option-o-1)' and for the second normal
(non-option-) argument it is `tt(argument-2)'.

Also, during the evaluation of the var(action), the context name in
the tt(curcontext) parameter is changed by appending the same
string that is stored in the tt(context) parameter.

It is also possible to specify multiple sets of options and
arguments with the sets separated by single hyphens.  The specifications
before the first hyphen are shared by all sets given after the first
hyphen.  The first word in every other set gives the name of the
set. This name may appear in exclusion lists in the specifications,
either alone or before one of the possible values described above
(with a `tt(-)' between the name and the rest).

For example:

example(_arguments \ 
    -a \ 
  - set1 \ 
    -c \ 
  - set2 \ 
    -d \ 
    ':arg:(x2 y2)')

This defines two sets. When the command line contains the option
`tt(-c)', the `tt(-d)' option and the argument will not be considered
possible completions. When it contains `tt(-d)' or an argument, the
option `tt(-c)' will not be completed any more, but if `tt(-a)' is
given, both sets will still be considered valid, because it appears
before the first hyphen, so both sets contain this option.

If the name-string is of the form `tt(LPAR())var(name)tt(RPAR())' then 
all specifications in the set have an implicit exclusion list
containing the name of the set, i.e. all specifications are mutual
exclusive with all other specifications in the same set. This is
useful for defining multiple sets of options which are mutually
exclusive and in which the options are aliases for each other. E.g.:

example(_arguments \ 
    -a -b \ 
  - '(compress)' \ 
    {-c,--compress}'[compress]' \ 
  - '(uncompress)' \ 
    {-d,--decompress}'[decompress]')

Note that using multiple sets will be slower than using only one set
because the completion code has to parse the command line once for
every set. So more than one set should only be used if the command
syntax is too complicated. Note also that an option specification with
rest-arguments (as in `tt(-foo:*:...)') often allows the use of
multiple sets to be avoided.

To simplify the specifications for commands with standard option
parsing, the options tt(-S) and tt(-A) may be given.  With tt(-S), no
option will be completed after a `tt(-)tt(-)' on the line and this
argument will otherwise be ignored. With tt(-A), no options will be
completed after the first non-option argument on the line.  The tt(-A) 
has to be followed by a pattern matching all strings which are not to
be taken as arguments. For example, to make tt(_arguments) stop
completing options after the first normal argument, but ignoring all
strings starting with a hyphen even if they are not described by one
of the var(optspec)s, one would use: `tt(-A "-*")'.

Another option supported is `tt(-O) var(name)'. The var(name) will be
taken as the name of an array and its elements will be given to
functions called to generate matches when executing the
var(actions). For example, this allows one to give options for the
tt(compadd) builtin that should be used for all var(action)s.

Also, the tt(-M) option followed by a string may be given before the
first description. The string will be used as the match specification
when completing option names and values instead of the default
`tt(r:|[_-]=* r:|=*)'. 

Finally, the option tt(-C) can be given to make tt(_arguments) modify
the tt(curcontext) parameter when an action of the form
`tt(->)var(state)' is used. This parameter is used to keep track of
the current context and in this case it (and not the parameter
tt(context) as explained above) has to be made local to make sure that 
calling functions don't use the modified value. Also, the local
version of tt(curcontext) has to be initialised with the old value as
in:

example(local curcontext="$curcontext")

The function can also be made to automatically complete long options
for commands that support the `tt(-)tt(-help)' option as, for example,
most of the GNU commands do. For this, the string `tt(-)tt(-)' must be
given as one argument and if it is, the command from the line is
invoked with the `tt(-)tt(-help)' option and its output is parsed to find
possible option names. Note that this means that you should be careful
to make sure that this feature is not used for a command that does not
support this option.

For such automatically found options that get an argument after an
`tt(=)', the function also tries
to automatically find out what should be completed as the argument.
The possible completions for option-arguments can be described with
the arguments after the `tt(-)tt(-)' (which are not used as described
above). Each argument contains one description of the form
`var(pattern)tt(:)var(message)tt(:)var(action)'. The var(message) and
the var(action) have the same format as for the normal option
descriptions described above. The var(action) will be executed to
complete arguments of options whose description in the output of the
command from the line with the `tt(-)tt(-help)' option matches the
var(pattern). For example:

example(_arguments -- '*\*:toggle:(yes no)' \ 
              '*=FILE*:file:_files' \ 
              '*=DIR*:directory:_files -/')

Here, `tt(yes)' and `tt(no)' will be completed as the argument of
options whose description ends in a star, file names for options that
contain the substring `tt(=FILE)' in the description, and paths for
options whose description contains `tt(=DIR)'. In fact, the last two
patterns are not needed since this function always completes files
for option descriptions containing `tt(=FILE)' and paths for option
descriptions that contain `tt(=DIR)' or `tt(=PATH)'. These builtin
patterns can be overridden by patterns given as arguments, however.

Note also that tt(_arguments) tries to find out automatically if the
argument for an option is optional. If it fails to automatically
detect this, the colon before the var(message) can be doubled to tell
it about this as described for the normal option descriptions above.

If the var(pattern) ends in `tt((-))', this will removed from the
pattern and the var(action) will be used only directly after the
`tt(=)', not in the next word. I.e., this is like a normal
specification as described above using `tt(=-)'.

The option `tt(-i) var(patterns)' (which must be given after the
`tt(-)tt(-)') can be used to give patterns for options which should not be
completed. The patterns can be given as the name of an array parameter
or as a literal list in parentheses. E.g. `tt(-i
"LPAR()-)tt(-(en|dis)able-FEATURE*RPAR()")' will make the options
`tt(-)tt(-enable-FEATURE)' and `tt(-)tt(-disable-FEATURE)' be ignored. The
option `tt(-s) var(pairs)' (again, after the `tt(-)tt(-)') can be used to
describe option aliases. Each var(pair) consists of a pattern and a
replacement. E.g. some tt(configure)-scripts describe options only as
`tt(-)tt(-enable-foo)', but also accept `tt(-)tt(-disable-foo)'. To allow
completion of the second form, one would use `tt(-s "LPAR()#-)tt(-enable-
-)tt(-disable-RPAR()")'.

Example:

example(_arguments '-l+:left border:' \ 
           '-format:paper size:(letter A4)' \ 
           '*-copy:output file:_files::resolution:(300 600)' \ 
           ':postscript file:_files -g \*.\(ps\|eps\)' \ 
           '*:page number:')

This describes three options: `tt(-l)', `tt(-format)', and
`tt(-copy)'. The first one gets one argument described as `var(left
border)' for which no completion will be offered because of the empty
action. The argument may come directly after the `tt(-l)' or it may be 
given as the next word on the line. The `tt(-format)' option gets one
argument (in the next word) described as `var(paper size)' for which
only the strings `tt(letter)' and `tt(A4)' will be completed. The
`tt(-copy)' option differs from the first two in that it may appear
more than once on the command line and in that it accepts two
arguments. The first one is mandatory and will be completed as a
filename. The second one is optional (because of the second colon
before the description `var(resolution)') and will be completed from
the strings `tt(300)' and `tt(600)'.

The last two descriptions say what should be completed as
arguments. The first one describes the first argument as a
`var(postscript file)' and makes files ending in `tt(ps)' or `tt(eps)' 
be completed. The last description says that all other arguments are
`var(page numbers)' but does not give possible completions.
)
findex(_cache_invalid)
item(tt(_cache_invalid) var(cache_identifier))(
This function returns 0 if the completions cache corresponding to the
given cache identifier needs rebuilding.  It determines this by
looking up the tt(cache-policy) style for the current context, and
if it exists, runs the function of the same name, supplying the full
path to the relevant cache file as the only argument.

Example:

example(_example_caching_policy () {
    # rebuild if cache is more than a week old
    oldp=( "$1"(Nmw+1) )
    (( $#oldp ))
})
)
findex(_call_function)
item(tt(_call_function) var(return) var(name) [ var(args) ... ])(
If a function var(name) exists, it is called with the arguments
var(args). Unless it is the empty string or a single hyphen,
var(return) is taken as the name of a parameter and the return status
from the called function is stored in it.
The return value of tt(_call_function) itself is zero if the function
var(name) exists and was called and non-zero otherwise.
)
findex(_call_program)
item(tt(_call_program) var(tag) var(string) ...)(
This function is used in places where a command is called, making it
possible for the user to override the default command call.  It looks up
the tt(command) style with the supplied var(tag).  If the style is set, its
value is used as the command to execute.

In any case, the var(string)s from the call to tt(_call_program) or from the
style are concatenated with spaces between them and the resulting
string is evaluated.  The return value is the return value of the
command called.
)
findex(_combination)
item(tt(_combination) [ tt(-s) var(pattern) ] var(tag) var(style) var(specs) ... var(field) var(opts) ...)(
This function is used to complete combinations of values such as pairs 
of hostnames and usernames.  The possible values will be taken from the 
var(style) whose name is given as the second argument.  The first argument
is the var(tag) to use to do the lookup.

The style name should consist of multiple parts separated by
hyphens which are then used as field names.  Known values for such
fields can be given after the second argument in arguments of the form 
`var(field)tt(=)var(pattern)'.  The first argument without an equals sign 
is taken as the name of the field for which completions should be
generated.

The matches generated will be taken from the value of the style.  These 
values should contain the possible values for the combinations where
the values for the different fields are separated by colons or
characters matching the pattern given after the tt(-s) option to
tt(_combination); normally this is used to define character classes
like the `tt(-s "[:@]")' used for the tt(users-hosts) style.

Only the values for the requested fields for which the patterns given
in the `var(field)tt(=)var(pattern)' match the respective fields in
the strings from the style value are generated as possible matches.

If no style with the given name is defined for the given tag but a
function named with the name of the requested field preceded by an
underscore is defined, that function will be called to generate the
matches.  This is also done if none of the strings in the value of the
style match all the patterns given as arguments.

If the same name is used for more than one field, in both the
`var(field)tt(=)var(pattern)' and the argument that gives the field
name to complete for, the number of the field (starting with one) may
be given after the fieldname, separated from it by a colon.

All arguments after the requested field name are passed to
tt(compadd) when generating matches from the style value, or to 
the functions for the fields if they are called.
)
findex(_contexts)
item(tt(_contexts) var(names) ...)(
This function looks up the definitions for the context and command
names given as arguments and calls the handler functions for them if
there is a definition (given with the tt(compdef) function).  For
example, the function completing inside subscripts might use
`tt(_contexts -math-)' to include the completions generated for
mathematical environments.
)
findex(_describe)
item(tt(_describe) [ tt(-o) ] var(descr) var(name1) [ var(name2) ] var(opts) ... tt(-)tt(-) ...)(
This function is useful for preparing a list of command options or
arguments, together with their descriptions var(descr), as matches.
Multiple groups separated by tt(-)tt(-) can be supplied, potentially with
different completion options var(opts).

The var(descr) is taken as a string to display above the matches if the
tt(format) style for the tt(descriptions) tag is set.  After this come one
or two names of arrays followed by options to pass to tt(compadd).  The
first array contains the possible completions with their descriptions in
the form `var(completion)tt(:)var(description)'.  If a second array is
given, it should have the same number of elements as the first one and the
corresponding elements are added as possible completions instead of the
var(completion) strings from the first array.  The completion list will
retain the descriptions from the first array.  Finally, a set of completion
options can appear.

If the option `tt(-o)' appears before the first argument, the matches added
will be treated as option names (typically following a `tt(-)',
`tt(-)tt(-)' or `tt(+)' on the command line).  This makes tt(_describe) use
the tt(prefix-hidden), tt(prefix-needed) and tt(verbose) styles to find out
if the strings should be added at all and if the descriptions should be
shown.  Without the `tt(-o)' option, only the tt(verbose) style is used.

tt(_describe) uses the tt(_all_labels) function to generate the matches, so
it does not need to appear inside a loop over tag labels.
)
findex(_description)
item(tt(_description) [ tt(-12VJ) ] var(tag) var(name) var(descr) [ var(specs) ... ])(
This function is called before completions are added (typically by a call
to tt(compadd)); it tests various styles and arranges for any necessary
options to be passed on to tt(compadd).  The styles are tested in the
current context using the given var(tag); options are put into the array
called var(name) for passing on to tt(compadd); the description for the
current set of matches is passed in var(descr).  The styles tested are:
tt(format) (which is first tested for the given var(tag) and then for the
tt(descriptions) tag if that isn't defined), tt(hidden), tt(matcher),
tt(ignored-patterns) and tt(group-name) (the last are tested only for the
tag given as the first argument).  This function also calls the tt(_setup)
function which tests some more styles.

The string returned by the tt(format) style (if any) will be modified so
that the sequence `tt(%d)' is replaced by the var(descr) given as the third
argument without any leading or trailing white space.  If, after
removing the white space, the var(descr) is the empty string, the format
style will not be used and the options put into the var(name) array will
not contain an explanation string to be displayed above the matches.  If
tt(_description) is called with more than three arguments,
the additional var(specs) should be of the form `var(char)tt(:)var(str)'
and every appearance of `tt(%)var(char)' in the format string will be
replaced by var(string).

The options placed in the array will also make sure that the matches
are placed in a separate group, depending on the value of the
tt(group-name) style.  Normally a sorted group will be used for this
(with the `tt(-J)' option), but if an option starting with `tt(-V)',
`tt(-J)', `tt(-1)', or `tt(-2)' is given, that option will be included
in the array, so that it is possible to make the group unsorted by
giving the option `tt(-V)', `tt(-1V)', or `tt(-2V)'. 

In most cases, the function will be used like this:

example(local expl
_description files expl file
compadd "$expl[@]" - "$files[@]")

Note the use of the parameter tt(expl), the hyphen, and the list of
matches.  Almost all calls to tt(compadd) within the completion system use
a similar format; this ensures that user-specified styles are correctly
passed down to the builtins which implement the internals of completion.
)
findex(_files)
item(tt(_files))(
The function tt(_files) uses the tt(file-patterns) style and calls
tt(_path_files) with all the arguments it was passed except for tt(-g) 
and tt(-/).  These two options are used depending on the setting of the 
tt(file-patterns) style.

See tt(_path_files) below for a description of the full set of options
accepted by tt(_files).
)
findex(_gnu_generic)
item(tt(_gnu_generic))(
This function is a simple wrapper around the tt(_arguments) function
described above.  It can be used to automatically complete long
options for commands that understand the `tt(-)tt(-help)' option.
It is not intended to be used from completion functions but as a
top-level completion function in its own right.  For example, to
enable option completion for the commands tt(foo) and tt(bar), one
would call:

example(compdef _gnu_generic foo bar)

in one of the initialization files after the call to tt(compinit).

The default installation uses this function only to generate
completions for some GNU-commands because to complete the options, the 
command has to be called and hence it shouldn't be used if one can't
be sure that the command understands the `tt(-)tt(-help)' option.
)
findex(_guard)
item(tt(_guard) [ var(options) ] var(pattern) [ var(descr) ])(
This function is intended to be used in an action of functions like
tt(_arguments).  It returns immediately with a non-zero return value if
the string to be completed does not match the var(pattern).  If the
pattern matches, the var(descr) is displayed and the function returns
zero if the word to complete is not empty and non-zero otherwise.

The var(pattern) may be preceded by those options understood by
tt(compadd) that are passed down from tt(_description), namely tt(-M),
tt(-J), tt(-V), tt(-1), tt(-2), tt(-n), tt(-F) and tt(-X).  All of these
options, except tt(-X), will be ignored.  If the tt(-X) option appears,
the description following it will be used as the string to display if
the var(pattern) matches, unless the option var(descr) is given to
tt(_guard) itself, which will then take precedence.

As an example, consider a command taking the options tt(-n) and
tt(-none), where tt(-n) has to be followed by a numeric value in the
same word.  By using either of:

example(_argument '-n-:numeric value:_guard "[0-9]#"' '-none')

or

example(_argument '-n-: :_guard "[0-9]#" "numeric value"' '-none')

tt(_arguments) can be made to both display the message `tt(numeric
value)' and complete options after `tt(-n<TAB>)'.  If the `tt(-n)' is
already followed by one or more digits (matching the pattern given to
tt(_guard)), only the message will be displayed and if the `tt(-n)' is
followed by another character, only options are completed.
)
findex(_message)
item(tt(_message) [ -r ] var(descr))(
The var(descr) is used like the third
argument to the tt(_description) function. However, the resulting
string will always be shown whether or not matches were
generated. This is useful to display help texts in places where no
completions can be generated automatically.

This function also uses the tt(format) style for the tt(messages) tag in
preference to the tt(format) style for the tt(descriptions) tag. The
latter is used only if the former is unset.

If the tt(-r) option is given, no style is used and the var(descr) is
used literally as the string to display. This is only used in cases
where that string is taken from some pre-processed argument list
containing an expanded description.
)
findex(_multi_parts)
item(tt(_multi_parts) var(sep) var(array))(
This function receives two arguments: a separator character and an
array.  As usual, the var(array) may be either the
name of an array parameter or a literal array in the form
`tt(LPAR()foo bar)tt(RPAR())' (i.e. a list of words separated by white 
space in parentheses).  With these arguments, this function will
complete to strings from the array where the parts separated by the
separator character are completed independently.  For example, the
tt(_tar) function from the distribution caches the pathnames from the
tar file in an array, and then calls this function to complete these
names in the way normal filenames are completed by the
tt(_path_files) function, by using `tt(_multi_parts) tt(/)
var(patharray)'.

If the tt(-i) option is present, then any time there is a unique match it
will immediately be inserted even if that requires additional separators to
be inserted as well.  When completing from a fixed set of possible
completions which are really words, this is often the expected behaviour;
however, if tt(_multi_parts) should behave like completing pathnames, the
tt(-i) option should not be used.

Like other utility functions, this function accepts the `tt(-V)',
`tt(-J)', `tt(-1)', `tt(-2)', `tt(-n)', `tt(-f)', `tt(-X)', `tt(-M)',
`tt(-P)', `tt(-S)', `tt(-r)', `tt(-R)', and `tt(-q)' options and passes
them to the tt(compadd) builtin.
)
findex(_next_label)
item(tt(_next_label) [ tt(-12VJ) ] var(tag) var(name) var(descr) [ var(options) ... ])(
This function should be called repeatedly to generate the tag
labels. On each call it will check if another tag label is to be used 
and, if there is at least one, zero is returned. If no more tag
labels are to be used, a non-zero status is returned.

The tt(-12JV) options and the first three arguments are given to the
tt(_description) function using the tag label instead of the first
argument as appropriate. The var(options) given after the var(descr)
should be other options to be used for tt(compadd) or whatever
function is to be called to add the matches. tt(_next_label) will store these 
var(options) in the parameter whose var(name) is given as the second
argument. This is done in such a way that the description given by the 
user to the tt(tag-order) style is preferred over the one given to
tt(_next_label).

Note that this function must not be called without a previous call to
tt(_tags) or tt(_requested) because it uses the tag label
for the current tag found by these functions.

A normal use of this function for the tag labels of the tag tt(foo)
looks like this:

example(local expl ret=1
...
if _requested foo; then
  ...
  while _next_label foo expl '...'; do
    compadd "$expl[@]" ... && ret=0
  done
  ...
fi
return ret
)
)
findex(_normal)
item(tt(_normal))(
This function is used for normal command completion.  It has two tasks:
completing the first word on the command line as the name of a command, and
completing the arguments to this command.  In the second case, the name of
the command is looked up to see if special completions exists, including
completions defined for patterns which match the name.  If none is found,
completion is performed for the context tt(-default-).

The function can also be called by other completion functions which need to
treat a range of words as a command line.  For example, the function to
complete after the pre-command specifiers such as tt(nohup) removes the
first word from the tt(words) array, decrements the tt(CURRENT) parameter,
then calls tt(_normal) again, with the effect that `tt(nohup) var(cmd ...)'
is treated the same way was `var(cmd ...)'.

If the command name matches a pattern, the parameter tt(_compskip) is
checked after the call to the corresponding completion function.  This has
the same effect here as in the tt(-first-) context: if it is set, no more
completion functions are called even if there are no matches so far.
)
findex(_options)
item(tt(_options))(
This can be used to complete option names.  It uses a matching
specification that ignores a leading `tt(no)', ignores underscores and 
allows the user to type upper-case letters which will match their
lower-case counterparts.  All arguments passed to this function are
propagated unchanged to the tt(compadd) builtin.
)
findex(_options_set)
findex(_options_unset)
item(tt(_options_set) and tt(_options_unset))(
These functions complete only set or unset options, with the same
matching specification used in the tt(_options) function.

Note that you need to uncomment a few lines in the tt(_main_complete)
function for these functions to work properly.  The lines in question
are used to store the option settings in effect before the completion
widget locally sets the options it needs.  Hence these options are not
generally used by the completion system.
)
findex(_parameters)
item(tt(_parameters))(
This should be used to complete parameter names.  tt(_parameters) can
take a tt(-g var(pattern)) option which specifies that only parameters
whose type matches the var(pattern) should be completed.  Strings of
the same form as those returned by the tt(t) parameter expansion flag
are used here when matching the type.  All other arguments are passed
unchanged to the tt(compadd) builtin.
)
findex(_path_files)
item(tt(_path_files))(
The function tt(_path_files) is used throughout the completion system
to complete filenames.  It allows completion of partial paths.  For
example, the string `tt(/u/i/s/sig)' may be completed to
`tt(/usr/include/sys/signal.h)'.

The options accepted by both tt(_path_files) and tt(_files) are:

startitem()
item(tt(-f))(
Complete all filenames.  This is the default.
)
item(tt(-/))(
Specifies that only directories should be completed.
)
item(tt(-g) var(pattern))(
Specifies that only files matching the var(pattern) should be completed.
)
item(tt(-W) var(paths))(
Specifies path prefixes that are to be prepended to the string from the
line to generate the filenames but that should not be inserted in the line
or shown in a completion listing.  Here, var(paths) may be the name of an
array parameter, a literal list of paths enclosed in parentheses or an
absolute pathname.
)
item(tt(-F))(
This option from the tt(compadd) builtin gives direct control over which
filenames should be ignored.  If the option is not present, the
tt(ignored-patterns) style is used.
)
enditem()

These functions also accept the `tt(-J)', `tt(-V)', `tt(-1)',
`tt(-2)', `tt(-n)', `tt(-X)', `tt(-M)', `tt(-P)', `tt(-S)', `tt(-q)',
`tt(-r)', and `tt(-R)' options from the tt(compadd) builtin.

Finally, the tt(_path_files) function  uses the styles tt(expand),
tt(ambiguous), tt(special-dirs), tt(list-suffixes) and tt(file-sort).
)
findex(_regex_arguments)
item(tt(_regex_arguments) var(name) var(specs) ...)(
This function is a compiler to generate a completion function.  The
first argument specifies the name of the generated function while the
remaining arguments specify a completion as a set of regular
expressions with actions.  The generated function has the structure of a
finite-state machine whose states correspond to the state (i.e. the
context) of the completion. This state machine uses a command line,
which comes from the concatenation of the tt(words) array up to the
current cursor position using null characters as separators with no extra
quotation.  This is analysed and at the end the appropriate action is
executed.

Specification arguments take one of following forms, in which
metacharacters such as `tt(LPAR())', `tt(RPAR())', `tt(#)' and `tt(|)'
should be quoted.

startitem()
item(tt(/)var(pattern)tt(/) [tt(%)var(lookahead)tt(%)] [tt(-)var(guard)] [tt(:)var(tag)tt(:)var(descr)tt(:)var(action)])(
This is a primitive element, corresponding to one
state of the compiled state machine.  The state is entered if
`tt((#b)LPAR()(#B))var(pattern)tt(RPAR()(#B))var(lookahead)tt(*)' matches
the command line string.  If it matches, `var(guard)' is evaluated and
its return status is examined; if this is successful, the state is entered,
otherwise the test fails and other candidates are tried.  The var(pattern)
string `tt([])' is guaranteed never to match.

If the test succeeds and the state is entered, the left part of the
command line string matched as var(pattern) is removed and the 
next state is tried, proceeding from inside to outside and from left to
right.

If no test succeeds and the remaining command line string contains no null
character, the completion target is restricted to the remainder of the
command line string and var(action)s for the target are executed.
In this case, nothing is actually removed from the command line string
so that any previous or neighbouring state may also have var(actions)s.
var(actions)s evaluation are ordered by the tt(tag-order) style and specified
var(tag) by tt(_alternative).  So, the various formats supported by
tt(_alternative) can be used in var(action).  var(descr) is used for
setting up the array parameter tt(expl).
)
item(tt(/)var(pattern)tt(/+) [tt(%)var(lookahead)tt(%)] [tt(-)var(guard)] [tt(:)var(tag)tt(:)var(descr)tt(:)var(action)])(
This is similar to `tt(/)var(pattern)tt(/) ...' but the left part of the
command line string is also considered as part of the completion target.
)
item(tt(/)var(pattern)tt(/-) [tt(%)var(lookahead)tt(%)] [tt(-)var(guard)] [tt(:)var(tag)tt(:)var(descr)tt(:)var(action)])(
This is similar to `tt(/)var(pattern)tt(/) ...' but the var(action)s of the
current and previous states are ignored even if the following state's
`var(pattern)' matches the empty string.
)
item(tt(LPAR()) var(spec) tt(RPAR()))(
This groups var(spec)s.
)
item(var(spec) tt(#))(
This allows any number of repetitions of var(spec).
)
item(var(spec) var(spec))(
This represents the concatenation of two var(spec)s.
)
item(var(spec) tt(|) var(spec))(
Either of the two var(spec)s can be matched.
)
enditem()
)
findex(_requested)
item(tt(_requested) [ tt(-12VJ) ] var(tag) [ var(name) var(descr) [ var(command) var(args) ... ] ])(
This function is called to decide whether a tag already registered by a
call to tt(_tags) (see below) is requested and hence completion should be
performed for it; it returns status zero if the tag is requested and
non-zero otherwise.  This will usually be done in a loop such as the
following:

example(_tags foo bar baz
while _tags; do
  if _requested foo; then
    ... # perform completion for foo
  fi
  ... # test the tags bar and baz in the same way
  ... # exit loop if matches were generated
done)

Note that the test for whether matches were generated is not performed
until the end of the tt(_tags) loop.  This is so that the user can specify
a set of tags to be tested at the same time in the tt(tag-order)
parameter.

If the var(name) and the var(descr) are given, tt(_requested) calls the
tt(_description) function with these arguments, including the options.

If the var(command) is given, the tt(_all_labels) function will be called
immediately with the same arguments.  This is often useful to do both the
testing of the tag, getting the description for the matches and adding the
matches at once.  For example:

example(local expl ret=1
_tags foo bar baz
while _tags; do
  _requested foo expl 'description' \ 
      compadd foobar foobaz && ret=0
  ...
  (( ret )) || break
done)

Note that this means that the var(command) has to accept the options
that have to be passed down to tt(compadd).
)
findex(_retrieve_cache)
item(tt(_retrieve_cache) var(cache_identifier))(
This function retrieves completion information from the file given by
var(cache_identifier), stored in a directory specified by the
tt(cache-path) style (defaults to tt(~/.zsh/cache)).  The return value
is zero if retrieval was successful.  It will only attempt retrieval
if the tt(use-cache) style is set, so you can call this function
without worrying about whether the user wanted to use the caching
layer.

See tt(_store_cache) below for more details.
)
findex(_sep_parts)
item(tt(_sep_parts))(
This function is passed alternating arrays and separators as arguments.
The arrays specify completions for parts of strings to be separated by the
separators.  The arrays may be the names of array parameters or
a quoted list of words in parentheses.  For example, with the array
`tt(hosts=(ftp news))' the call `tt(_sep_parts '(foo bar)' @ hosts)' will
complete the string  `tt(f)' to `tt(foo)' and the string `tt(b@n)' to
`tt(bar@news)'.

This function passes the `tt(-V)', `tt(-J)', `tt(-1)', `tt(-2)',
`tt(-n)', `tt(-X)', `tt(-M)', `tt(-P)', `tt(-S)', `tt(-r)', `tt(-R)',
and `tt(-q)' options and their arguments to the tt(compadd) builtin
used to add the matches.
)
findex(_setup)
item(tt(_setup) var(tag) [ var(group) ])(
This function expects a tag as its argument and sets up the special
parameters used by the completion system appropriately for the tag,
using styles such as tt(list-colors) and tt(last-prompt).

The optional var(group) gives the name of the group in which the
matches will be placed. If it is not given, the var(tag) is used as
the group name.

Note that this function is called automatically from tt(_description)
so that one normally doesn't have to call it explicitly.
)
findex(_store_cache)
item(tt(_store_cache) var(cache_identifier) var(vars) ...)(
This function, when combined with tt(_retrieve_cache) and
tt(_cache_invalid), makes it easy to implement a caching layer for
your completion functions.  If a completion function needs to perform
a costly operation in order to generate data which is used to
calculate completions, you can store that data in variables, and use
this function to dump the values of those variables to a file.  Then,
if they are needed in subsequent shell invocations, they can be
retrieved quickly from that file via tt(_retrieve_cache), avoiding the
need for repeating the costly operation.

The var(cache_identifier) specifies the file which the data should be
dumped to, and is stored in a directory specified by the
tt(cache-path) style (defaults to tt(~/.zsh/cache)).  The remaining
var(vars) arguments are the variables to dump to the file.

The return value is zero if storage was successful.  The function will
only attempt storage if the tt(use-cache) style is set, so you can
call this function without worrying about whether the user wanted to
use the caching layer.

If your completion function avoids calling _retrieve_cache when it
already has the completion data in the environment, it should probably
at least call tt(_cache_invalid) to check whether this data and the
data cached on disk is still valid.

See the _perl_modules completion function for a simple example of
usage of this caching layer.
)
findex(_tags)
item(tt(_tags) [ tt(-C) var(name) [ var(tags) ... ] ])(
If called with arguments, these are taken as the names of the tags for 
the types of matches the calling completion function can generate in
the current context.  These tags are stored internally and sorted by
using the tt(tag-order) style.  Following calls to this function
without arguments from the same function will then select the first,
second, etc. set of tags requested by the user.  To test if a certain
tag should be tried, the tt(_requested) function has to be called (see 
above).

The return value is zero if at least one of the tags is requested and
non-zero otherwise. 

This function also accepts the tt(-C) option followed by a
var(name). This name is temporarily (i.e. not visible outside
tt(_tags)) stored in the argument field of the context name in the
tt(curcontext) parameter. This allows tt(_tags) to be made to use a more
specific context name without having to change and reset the
tt(curcontext) parameter (which would otherwise have the same effect).
)
findex(_values)
item(tt(_values) var(specs) ...)(
This is used to complete values (strings) and their arguments or
lists of such values.  It can be used in two ways.

If the first argument is the option `tt(-O) var(name)', this will be used
in the same way as by the tt(_arguments) function, in other words the
elements of the var(name) array will be given to calls to tt(compadd)
and when executing an action.

Otherwise, if the first argument (or the first argument after the
`tt(-O) var(name)' option if that is used) is the option `tt(-s)', the
next argument is used as the character that separates multiple values.
Thus the values completed appear in the same word on the command line,
unlike completion using tt(_arguments).

The first argument (after the options and separator character if they
are given) is used as a string to print as a description before
listing the values.

All other arguments describe the possible values and their
arguments in the same format used for the description of options by
the tt(_arguments) function (see above).  The only differences are that
no minus or plus sign is required at the beginning, that
values can have only one argument and that those forms of actions
beginning with an equal sign are not supported.

The character separating a value from its argument can be set using the
option tt(-S) (like tt(-s), followed by the character to use as the
separator in the next argument).  If this option is not used, the equal
sign will be used as the separator.

Example:

example(_values -s , 'description' \ 
        '*foo[bar]' \ 
        '(two)*one[number]:first count:' \ 
        'two[another number]::second count:(1 2 3)')

This describes three possible values: `tt(foo)', `tt(one)', and
`tt(two)'.  The first is described as `tt(bar)', takes no argument 
and may appear more than once.  The second is described as
`tt(number)', may appear more than once, and takes one mandatory
argument described as `tt(first count)' for which no action is
specified so that it will not be completed automatically.  The
`tt((two))' at the beginning says that if the value `tt(one)' is on
the line, the value `tt(two)' will not be considered to be a possible
completion anymore.  Finally, the last value (`tt(two)') is described
as `tt(another number)' and takes an optional argument described as
`tt(second count)' which will be completed from the strings `tt(1)',
`tt(2)', and `tt(3)'. The tt(_values) function will complete lists of
these values separated by commas.

Like tt(_arguments) this function temporarily adds another context
name component to the current context name while executing the
var(action).  Here this name is just the name of the value for which
the argument is completed.

To decide if the descriptions for the values (not those for the
arguments) should be printed, the style tt(verbose) is used.

One last difference from tt(_arguments) is that this function uses the
associative array
tt(val_args) to report values and their arguments, although otherwise this
is the same as the tt(opt_args) association used by
tt(_arguments).  This also means that the function calling tt(_values) 
should declare the tt(state), tt(line), tt(context) and tt(val_args)
parameters as in:

example(local context state line
typeset -A val_args)

when using an action of the form `tt(->)var(string)'.  With this
function the tt(context) parameter will be set to the name of the
value whose argument is to be completed.

Note also that tt(_values) normally adds the character used as the
separator between values as a auto-removable suffix so that users don't
have to type it themselves.  But when using a `tt(->)var(string)' action
tt(_values) can't do that because the matches for the argument will be
generated by the calling function.  To get the usual behaviour, the
implementor of the calling function has to add the suffix directly by
passing the options `tt(-qS) var(x)' (where var(x) is the separator
character specified with the tt(-s) option of tt(_values)) to the
function generating the matches or to the tt(compadd) builtin.

Like tt(_arguments), tt(_values) supports the tt(-C) option in
which case you have to make the parameter tt(curcontext) local instead 
of tt(context) (as described above).
)
findex(_wanted)
item(tt(_wanted) [ tt(-C) var(name) ]  [ tt(-12VJ) ] var(tag) var(name) var(descr) var(command) var(args) ...)(
In many contexts, completion will generate one particular set of
matches (usually corresponding to a single tag); however, it is
still necessary to decide whether the user requires matches of this type.
This function is useful in such a case.

Like tt(_requested), it should be passed arguments as for tt(_description).
It calls tt(_tags) with the given var(tag) and if that returns zero 
(so that the var(tag) is requested by the user) it calls
tt(_description).  Hence to offer only one tag and immediately
use the description generated:

example(_wanted tag expl 'description' \ 
    compadd matches...)

Unlike tt(_requested), however, tt(_wanted) cannot be called without
the var(command).  This is because tt(_wanted) also implements the loop
over the tags, not just the one for the labels; conversely, it should not
be called in the middle of a tt(_tags) loop.

Note that, as for tt(_requested), the var(command) has to accept the options
that have to be passed down to tt(compadd).

Like tt(_tags) this function supports the tt(-C) option to give a
different name for the argument context field.
)
enditem()

texinode(Completion Directories)()(Completion Functions)(Completion System)
sect(Completion Directories)
cindex(completion system, directory structure)

In the source distribution, the files are contained in various
subdirectories of the tt(Completion) directory.  They may have been
installed in the same structure, or into one single function directory.
The following is a description of the files found in the original directory
structure.  If you wish to alter an installed file, you will need to copy
it to some directory which appears earlier in your tt(fpath) than the
standard directory where it appears.

startitem()
item(tt(Base))(
The core functions and special completion widgets automatically bound
to keys.  You will certainly need most of these, though will
probably not need to alter them.  Many of these are documented above.
)
item(tt(Zsh))(
Functions for completing arguments of shell builtin commands and
utility functions for this.  Some of these are also used by functions from
the tt(Unix) directory.
)
item(tt(Unix))(
Functions for completing arguments of external commands and suites of
commands.  They may need modifying for your system, although in many cases
some attempt is made to decide which version of a command is present.  For
example, completion for the tt(mount) command tries to determine the system
it is running on, while completion for many other utilities try to decide
whether the GNU version of the command is in use, and hence whether the
tt(--help) option is supported..
)
item(tt(X), tt(AIX), tt(BSD), ...)(
Completion and utility function for commands available only on some systems.
)
enditem()
